<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
<title>
    风中呓语
</title>
<!--[if lt IE 9]><script src="//cdn.bootcss.com/html5shiv/r29/html5.js"></script><![endif]-->
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport" />
<meta http-equiv="x-dns-prefetch-control" content="on">
<link rel="dns-prefetch" href="https://cdn.jsdelivr.net">
<meta name="author" content="Angus">
<meta name="description" content="我遇见你，是最美丽的意外">
<meta name="keywords" content="分享与记录">
<script async src="//instant.page/3.0.0" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>
<link rel="stylesheet" href="https://Angus1996.github.io/styles/main.css" />
<link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
<script type="text/javascript" src="https://apps.bdimg.com/libs/jquery/1.7.1/jquery.min.js"></script>

        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/itjoker233/Gridea-theme-Chic/assets/media/css/style.min.css" />
        <script src="https://cdn.jsdelivr.net/gh/itjoker233/Gridea-theme-Chic/assets/media/script/tocbot.min.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/itjoker233/Gridea-theme-Chic/assets/media/script/script.min.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/itjoker233/Gridea-theme-Chic/assets/media/script/icon.min.js"></script>
        
            <script src="https://cdn.jsdelivr.net/gh/ITJoker233/ITJoker233.github.io@latest/CDN/js/Card/prism.min.js"></script>
            <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/ITJoker233/ITJoker233.github.io@latest/CDN/css/Card/prism.min.css" />
            <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.1/dist/katex.min.css">
            <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.1/dist/katex.min.js"></script>
            
                <!--点击特效-->
                <script src="https://cdn.jsdelivr.net/gh/ITJoker233/ITJoker233.github.io@latest/CDN/js/love.min.js"></script>
                
                    <script src="https://cdn.jsdelivr.net/gh/itjoker233/Gridea-theme-Chic@latest/assets/media/script/APlayer.min.js"></script>
                    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css">
                    
                        <!--CDN样式-->
                        <script src="https://cdn.jsdelivr.net/gh/ITJoker233/ITJoker233.github.io@latest/CDN/js/hit-kounter-lc-0.3.0.js"></script>
                        <script src="https://cdn1.lncld.net/static/js/av-min-1.5.0.js"></script>
                        
                            <script>
                                (function() {
                                    var bp = document.createElement('script');
                                    var curProtocol = window.location.protocol.split(':')[0];
                                    if (curProtocol === 'https') {
                                        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
                                    } else {
                                        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
                                    }
                                    var s = document.getElementsByTagName("script")[0];
                                    s.parentNode.insertBefore(bp, s);
                                })();
                            </script>
                            
                                    <script type="text/javascript">
                                        var _hmt = _hmt || [];
                                        (function() {
                                            var hm = document.createElement("script");
                                            hm.src = "https://hm.baidu.com/hm.js?6fca3f6ec3267f530d1d6d5f097f5ba9";
                                            var s = document.getElementsByTagName("script")[0];
                                            s.parentNode.insertBefore(hm, s);
                                        })();
                                    </script>
                                    
</head>

<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo">
                <a href="https://Angus1996.github.io">
                    风中呓语
                </a>
            </div>
            <div id="tp-weather-widget"></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/">
                        首页
                    </a>
                    
                    <a class="menu-item" href="/posts">
                        文章
                    </a>
                    
                    <a class="menu-item" href="/archives">
                        归档
                    </a>
                    
                    <a class="menu-item" href="/tags">
                        标签
                    </a>
                    
                    <a class="menu-item" href="/post/about">
                        关于
                    </a>
                    
                    <a class="menu-item" href="/friends">
                        常用链接
                    </a>
                    
                        <input id="switch_default" type="checkbox" class="switch_default">
                        <label for="switch_default" class="toggleBtn"></label>
            </div>
            <form id="gridea-search-form" data-update="1666016988061" action="/search/index.html">
                <input class="search-input" autocomplete="off" spellcheck="false" name="q" autofocus="true" placeholder="Search...">
            </form>
        </div>
    </nav>

    
        <nav class="navbar-mobile" id="nav-mobile">
            <div class="container">
                <div class="navbar-header">
                    <div>
                        <a href="https://Angus1996.github.io">
                            风中呓语
                        </a>
                        <!--en-->
                        <a id="mobile-toggle-theme-en" class="a en">&nbsp;Dark</a>
                        <!--zh-->
                        <a id="mobile-toggle-theme-zh" class="a zh">&nbsp;&#x6697;&#x9ED1;</a>
                    </div>
                    <form id="gridea-search-form" data-update="1666016988061" action="/search/index.html">
                        <input class="search-input" autocomplete="off" spellcheck="false" name="q" autofocus="true" placeholder="Search...">
                    </form>
                    <!--en-->
                    <div class="menu-toggle" id="menu-toggle-en" onclick="mobileBtn()">&#9776; Menu</div>
                    <!--zh-->
                    <div class="menu-toggle" id="menu-toggle-zh" onclick="mobileBtn()">&#9776; &#x83DC;&#x5355;</div>

                </div>
                <div class="menu" id="mobile-menu">
                    
                        <a class="menu-item" href="/">
                            首页
                        </a>
                        
                        <a class="menu-item" href="/posts">
                            文章
                        </a>
                        
                        <a class="menu-item" href="/archives">
                            归档
                        </a>
                        
                        <a class="menu-item" href="/tags">
                            标签
                        </a>
                        
                        <a class="menu-item" href="/post/about">
                            关于
                        </a>
                        
                        <a class="menu-item" href="/friends">
                            常用链接
                        </a>
                        
                </div>
            </div>
        </nav>
</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementById("menu-toggle-en");
        var toggleMenu_zh = document.getElementById("menu-toggle-zh");

        var mobileMenu = document.getElementById("mobile-menu");
        if (toggleMenu.display != "none") {
            if (toggleMenu.classList.contains("active")) {
                toggleMenu.classList.remove("active")
                mobileMenu.classList.remove("active")
            } else {
                toggleMenu.classList.add("active")
                mobileMenu.classList.add("active")
            }
        } else if (toggleMenu_zh.display != "none") {
            if (toggleMenu_zh.classList.contains("active")) {
                toggleMenu_zh.classList.remove("active")
                mobileMenu.classList.remove("active")
            } else {
                toggleMenu_zh.classList.add("active")
                mobileMenu.classList.add("active")
            }
        }

    }
</script>



    <script>
        (function(a, h, g, f, e, d, c, b) {
            b = function() {
                d = h.createElement(g);
                c = h.getElementsByTagName(g)[0];
                d.src = e;
                d.charset = "utf-8";
                d.async = 1;
                c.parentNode.insertBefore(d, c)
            };
            a["SeniverseWeatherWidgetObject"] = f;
            a[f] || (a[f] = function() {
                (a[f].q = a[f].q || []).push(arguments)
            });
            a[f].l = +new Date();
            if (a.attachEvent) {
                a.attachEvent("onload", b)
            } else {
                a.addEventListener("load", b, false)
            }
        }(window, document, "script", "SeniverseWeatherWidget", "//cdn.sencdn.com/widget2/static/js/bundle.js?t=" + parseInt((new Date().getTime() / 100000000).toString(), 10)));
        window.SeniverseWeatherWidget('show', {
            flavor: "slim",
            location: "WWEFQFPJZ7T8",
            geolocation: true,
            language: "auto",
            unit: "c",
            theme: "auto",
            token: "61bcc333-3305-4728-9465-6785274bb0a3",
            hover: "enabled",
            container: "tp-weather-widget"
        })
    </script>
    
            <div class="main">
                <div class="container">
                    <article class="post-wrap">
                        <header class="post-header">
                            <h1 class="post-title">
                                《算法 4th edition》学习笔记
                            </h1>
                            
                                    <!--zh-->
                                    <div class="post-meta zh">
                                        &#x4F5C;&#x8005;:
                                        <a itemprop="author" rel="author" href="/">
                                            风中呓语
                                        </a>
                                        <span class="post-time">&#x65E5;&#x671F;: <a href="#">2020-02-15</a></span>
                                        <span class="post-readtime">&#x9605;&#x8BFB;&#x65F6;&#x95F4;:<a
                                    href="#">84.7
                                    &#x5206;&#x949F;</a></span>
                                        <span class="post-words">&#x5B57;&#x6570;:<a href="#">21538</a></span>
                                        
                                            <span class="post-category">&#x5206;&#x7C7B;:
                                
                                <a href="https://Angus1996.github.io/tag/suan-fa/">算法</a>
                                
                            </span>
                                            
                                                阅读量:
                                                <span data-hk-page="current"> - </span>
                                                
                                    </div>
                                    
                        </header>
                        
                            <img class="post-feature-image" src="https://Angus1996.github.io/post-images/lesslesssuan-fa-4th-editiongreatergreater-xue-xi-bi-ji.jpg" alt="">
                          
                        <div class="post-content">
                            <h2 id="chapter-1-基础">chapter 1 基础</h2>
<h3 id="11-基础编程模型">1.1 基础编程模型</h3>
<ul>
<li>
<p>数组名表示的是整个数组——如果我们将一个数组变量赋予另一个变量，那么两个变量将会指向同一个数组。</p>
<pre><code class="language-java">int[] a = new int[N];
...
a[i] = 1234;
...
int[] b = a;
...
b[i] = 5678; //a[i]也会变成5678
</code></pre>
<p>这种情况叫做 <strong>起别名</strong> ，有时可能会导致难以察觉的问题。如果你想将数组复制一份，应该声明、创建并初始化一个新的数组，然后将原数组中的元素挨个复制到新的数组。</p>
</li>
</ul>
<h3 id="12-数组抽象">1.2 数组抽象</h3>
<ul>
<li>
<p><strong>数据类型</strong> 指的是一组值和一组对这些值的操作的集合。</p>
</li>
<li>
<p>Java编程的基础主要是使用<strong>class</strong> 关键字构造被称为<strong>引用类型</strong>的数据类型。</p>
</li>
<li>
<p><strong>对象</strong> 是能够承载数据类型的值的实体。所有对象都有三大重要特性：<strong>状态</strong>、<strong>标识</strong>和<strong>行为</strong> 。对象的<strong>状态</strong>即数据类型中的值。对象的<strong>标识</strong>就是它在内存中的位置。对象的<strong>行为</strong>就是数据类型的操作。</p>
</li>
<li>
<p><strong>引用</strong>是访问对象的一种方式。Java使用术语<strong>引用类型</strong>以示和原始数据类型（变量和值相关联）的区别。不同的Java实现中引用的实现细节也各不同，但可以认为<strong>引用就是内存地址</strong>。</p>
</li>
<li>
<p><strong>构造函数</strong>没有返回值，因为它总是返回它的数据类型的对象的引用。</p>
</li>
<li>
<p>每当用例调用了<strong>new()</strong>，系统都会：1️⃣ 为新的对象分配内存空间； 2️⃣ 调用构造函数初始化对象中的值；   3️⃣ 返回该对象的一个引用。</p>
</li>
<li>
<p><strong>静态方法</strong> 的主要作用是实现函数；非静态（实例）方法的主要 作用是实现数据类型的操作。静态方法调用的开头是<strong>类名</strong>（按习惯为大写），而非静态方法调用的开头总是<strong>对象名</strong>（按习惯为小写）。</p>
</li>
<li>
<p>使用引用类型的赋值语句将会创建该引用的一个副本。赋值语句不会创建新的对象，而只是创建另一个指向某个已经存在的对象的引用。这种情况叫做<strong>别名</strong>。</p>
</li>
<li>
<p>创建一个对象的数组需要一下两个步骤：</p>
<p>1️⃣ 使用方括号语法调用数组的构造函数创建数组；</p>
<p>2️⃣ 对于每个数组元素调用它的构造函数创建相应的对象。</p>
</li>
</ul>
<h3 id="13-背包-栈-队列">1.3 背包、栈、队列</h3>
<ul>
<li>
<p>集合类的抽象数据类型的一个关键特性是我们应该可以用它们存储任意类型的数据。一种特别的Java机制能够做到这一点，被称为<strong>泛型</strong>，也叫做 <strong>参数化类型</strong>。</p>
</li>
<li>
<p>背包是一种不支持从中删除元素的集合数据类型——他的目的是帮助用例收集元素并迭代遍历所有收集到的元素。迭代的顺序不确定且与用例无关。</p>
</li>
<li>
<p>先进先出队列（简称队列）是一种基于先进先出（FIFO）策略的集合类型。</p>
</li>
<li>
<p>下压栈（简称栈）是一种基于后进先出（LIFO）策略的集合类型。</p>
<p>典型用例：<strong>用两个栈解决未省略括号的算术表达式求值：</strong></p>
<ol>
<li>将操作数压入操作数栈；</li>
<li>将运算符压入运算符栈；</li>
<li>忽略左括号；</li>
<li>在遇到右括号时，弹出一个运算符，弹出所需数量的操作数，并将运算符和操作数的运算结果压入操作数栈。</li>
</ol>
</li>
<li>
<p>链表是一种递归的数据结构，它或者为空(null)，或者是指向一个节点(node)的引用。该结点含有一个泛型的元素和一个指向另一条链表的引用。</p>
<pre><code class="language-java">private class Node{
	Item item;
	Node next;
}
</code></pre>
<p>两个实例变量：Item(参数类型)和Node；Item是一个占位符，表示任意数据类型；</p>
<pre><code class="language-java">Node first = new Node() #first是指向一个Node对象的引用，使用first.item和first.next访问它的实例变量。
</code></pre>
</li>
<li>
<p><strong>访问链表中所有元素：</strong> 将循环的索引变量 <strong>x</strong> 初始化为链表的首结点。然后通过 <strong>x.item</strong> 访问和 <strong>x</strong> 相关联的元素，并将 <strong>x</strong> 设为 <strong>x.next</strong> 来访问链表中的下一个结点，如此反复直到 <strong>x</strong> 为null为止（已经到达了链表的尾部）。</p>
<pre><code class="language-java">for(Node x = first; x != null; x = x.next){
	//处理x.item
}
</code></pre>
</li>
<li>
<p>数组和链表常常被称为顺序存储和链式存储。</p>
</li>
<li>
<p>在泛型中，如果将错误类型的对象压入栈中，会发生 <strong>编译时报错</strong> 。</p>
</li>
<li>
<p>问：为什么将Node声明为嵌套类？为什么使用private?</p>
<p>答：将Node声明为私有的嵌套类之后，我们可以将Node的方法和实例变量的访问范围限制在包含他的类中。私有嵌套类的一个特点是只有包含他的类能够直接访问它的实例变量，因此无需将它的实例变量声明为public或者private。非静态的嵌套类也被称为<strong>内部类</strong>。（<em>在写链表结点的定义时，注意是否为嵌套类定义</em>）</p>
</li>
<li>
<p>编写一个函数，接受一条链表的首结点作为参数，（破坏性地）将链表反转并返回结果链表的首结点。</p>
<p><strong>迭代方式的解答</strong>：记录链表中的三个连续的结点：reverse、first和second。在每轮迭代中，我们从原链表中提取结点first并将它插入逆链表的开头。我们需要一直保持first指向原链表的所有剩余结点的首结点，second指向原链表中所有剩余结点的第二个结点，reverse指向结果链表的首结点。</p>
<pre><code class="language-java">public Node reverse(Node x){
	Node first = x;
	Node reverse = null;
	while(first != null){
		Node second = first.next;
		first.next = reverse;
		reverse = first;
		first = second;
	}
	return reverse
}
</code></pre>
<p><strong>递归解答：</strong> 假设链表含有N个结点，我们先递归颠倒最后N-1个结点，然后小心地将原链表中的首结点插入到结果链表的末端。</p>
<pre><code class="language-java">public Node reverse(Node first){
	if (first == null) return null;
	if (first.next == null) return first;
	Node second = first.next;
	Node rest = reverse(second);
	second.next = first;
	first.next = null;
	return rest;
}
</code></pre>
</li>
</ul>
<h3 id="14-算法分析">1.4 算法分析</h3>
<ul>
<li>
<p>一个程序运行的总时间主要和两点有关：1️⃣ ​执行每条语句的耗时；2️⃣ 执行每条语句的频率。前者取决于计算机、Java编译器和操作系统，后者取决于程序本身和输入。</p>
</li>
<li>
<p>执行最频繁的指令决定了程序执行的总时间——我们将这些指令称之为程序的内循环。许多程序的运行时间都只取决于其中的一小部分指令。</p>
</li>
<li>
<p><strong>统计一个文件中所有和为的三整数元组的数量（ThreeSum问题）</strong></p>
<pre><code class="language-java">// 暴力破解法
public class ThreeSum{
    public static int count(int[] a){
        int N = a.length;
        int cnt = 0;
        for (int i = 0;i &lt; N; i++)
            for (int j = i+1; j &lt; N; j++)
                for (int k = j+1; k &lt; N; k++)
                    if (a[i]+a[j]+a[k] == 0)
                        cnt++;
        return cnt;
    }
    public static void main(String[] args){
        int[] a = In.readInts(args[0]);
        StdOut.println(count(a));
    }
}
</code></pre>
<p>ThreeSum 的运行时间的增行数量级是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>N</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">N^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span> ，这与它是由Java实现或是它运行在哪台电脑上无关。使用的算法决定了增长的数量级。（可以使用数学归纳法证明从<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 个数中取三个整数的不同组合的总数为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>(</mo><mi>N</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>(</mo><mi>N</mi><mo>−</mo><mn>2</mn><mo>)</mo><mi mathvariant="normal">/</mi><mn>6</mn></mrow><annotation encoding="application/x-tex">N(N-1)(N-2)/6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">6</span></span></span></span></p>
</li>
<li>
<p>对于大多数程序，得到其运行时间的数学模型所需的步骤如下：</p>
<p>1️⃣ 确定输入模型，定义问题的规模；</p>
<p>2️⃣ 识别内循环；</p>
<p>3️⃣ 根据内循环中的操作确定成本模型；</p>
<p>4️⃣ 对于给定的输入，判断这些操作的执行频率。</p>
<pre><code class="language-java">for (int i = 1; i &lt; N; i++)
    for (int j = i+1;j &lt; N; j++)
        for (int k = j+1; k &lt; N; k++)
        	if (a[i] + a[j] + a[k] == 0) cnt++;
</code></pre>
</li>
<li>
<p><strong>对增长数量级的常见假设的总结</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">描述</th>
<th style="text-align:left">增长的数量级</th>
<th style="text-align:left">典型的代码</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">举例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">常数级别</td>
<td style="text-align:left">1</td>
<td style="text-align:left">a = a + b</td>
<td style="text-align:left">普通语句</td>
<td style="text-align:left">将两个数相加</td>
</tr>
<tr>
<td style="text-align:left">对数级别</td>
<td style="text-align:left"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">log N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span></td>
<td style="text-align:left">二分查找</td>
<td style="text-align:left">二分策略</td>
<td style="text-align:left">二分查找</td>
</tr>
<tr>
<td style="text-align:left">线性级别</td>
<td style="text-align:left"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span></td>
<td style="text-align:left">double max = a[0];<br/>for (int i = 1; i &lt; N; i++)<br/>	if (a[i] &gt; max) max = a[i];</td>
<td style="text-align:left">循环</td>
<td style="text-align:left">找出最大元素</td>
</tr>
<tr>
<td style="text-align:left">线性对数级别</td>
<td style="text-align:left"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">NlogN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span></td>
<td style="text-align:left">归并排序</td>
<td style="text-align:left">分治</td>
<td style="text-align:left">归并排序</td>
</tr>
<tr>
<td style="text-align:left">平方级别</td>
<td style="text-align:left"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>N</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">N^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></td>
<td style="text-align:left">for (int i = 1; i &lt; N; i++)<br/>    for (int j = i+1;j &lt; N; j++)<br/>        if (a[i] + a[j] == 0) cnt++;</td>
<td style="text-align:left">双层循环</td>
<td style="text-align:left">检查所有元素对</td>
</tr>
<tr>
<td style="text-align:left">立方级别</td>
<td style="text-align:left"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>N</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">N^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span></td>
<td style="text-align:left">for (int i = 1; i &lt; N; i++)<br/>    for (int j = i+1;j &lt; N; j++)<br/>        for (int k = j+1; k &lt; N; k++)<br/>        	if (a[i] + a[j] + a[k] == 0) cnt++;</td>
<td style="text-align:left">三层循环</td>
<td style="text-align:left">检查所有三元组</td>
</tr>
<tr>
<td style="text-align:left">指数级别</td>
<td style="text-align:left"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>N</mi></msup></mrow><annotation encoding="application/x-tex">2^N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span></span></span></span></td>
<td style="text-align:left">ch6</td>
<td style="text-align:left">穷举查找</td>
<td style="text-align:left">检查所有子集</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>平方级别、立方级别和指数级别的算法对于大规模的问题是不可用的。许多重要问题的直观解法是平方级别的，但我们也可以找到它们线性对数级别的算法。</p>
</li>
<li>
<p><strong>2-sum问题的线性对数级别的解法</strong></p>
<p>首先对数组排序（为二分查找做准备），  然后对于数组中的每个 <strong>a[i]</strong> ，使用 <strong>BinarySearch</strong> 的**rank()**方法对 **-a[i]**进行二分查找。归并排序所需时间和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">NlogN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 成正比，二分查找所需的时间和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">logN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 成正比，因此整个算法的运行时间和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">NlogN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 成正比。</p>
<pre><code class="language-java">import java.util.Arrays;
public class TwoSumFast{
    public static int count(int[] a){
        Arrays.sort(a);	//归并排序
        int N = a.length;
        int cnt = 0;
        for (int i = 0; i &lt; N; i++){
            if (BinarySearch.rank(-a[i]， a) &gt; i)
                cnt++;
        }
        return cnt;
    }
    public static void main(String[] args){
        int[] a = In.readInts(args[0]);
        Stdout.println(count(a));
    }
}
</code></pre>
</li>
<li>
<p><strong>3-sum问题的快速算法</strong></p>
<p>对数组排序并进行 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>(</mo><mi>N</mi><mo>−</mo><mn>1</mn><mo>)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">N(N-1)/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span></span></span></span> 次二分查找，每次查找所需的时间都和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">logN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 成正比。因此总运行时间和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>N</mi><mn>2</mn></msup><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">N^2 logN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 成正比。</p>
<pre><code class="language-java">import java.util.Arrays;
public class ThreeSumFast{
    public static int count(int[] a){
        Arrays.sort(a);	//归并排序
        int N = a.length;
        int cnt = 0;
        for (int i = 0; i &lt; N; i++){
            for (int j = i+1; j &lt; N; j++)
            	if (BinarySearch.rank(-a[i]-a[j]， a) &gt; j)
                	cnt++;
        }
        return cnt;
    }
    public static void main(String[] args){
        int[] a = In.readInts(args[0]);
        Stdout.println(count(a));
    }
}
</code></pre>
</li>
<li>
<p>调用 <strong>substring()</strong> 方法时，就创建了一个新的 <strong>string</strong> 对象（40字节），但是它仍重用了相同的 <strong>value[]</strong> 数组，因此该字符串的子字符串只会使用40字节的内存。</p>
</li>
<li>
<p>程序调用一个方法时，系统会从内存中的一个特定区域为方法分配所需的内存（用于保存局部变量），这个区域叫做 <strong>栈</strong> （Java系统的下压栈）。当方法返回时，它所占用的内存也被返回给了系统栈。因此，在递归程序中创建数组或是其他大型对象是很危险的，因为这意味着每一次递归调用都会使用大量的内存。</p>
</li>
<li>
<p>当通过 <strong>new</strong> 创建对象时，系统会从 <strong>堆内存</strong> 的另一块特定区域为该对象分配所需的内存。</p>
</li>
</ul>
<h3 id="15-union-find算法">1.5 union-find算法</h3>
<ul>
<li>union-find算法也就是经典的<strong>并查集</strong>算法，用于解决<strong>动态连通性</strong>问题.通过对这个算法的一步步更新可以体会到算法优化的思想和好处.</li>
<li><strong>基本思想</strong>:对于给定的两个触点，判断它们所在的连通分量是否相同，将查找连通分量称为<strong>find</strong>.如果未连通，则将这两个触点以及分别与它们连通的触点连通，将连通称为<strong>union</strong>.</li>
<li><strong>基础实现</strong>:使用一个id数组，保证在同一连通分量中的所有触点在id数组中的值是全部相同的.</li>
</ul>
<ol>
<li><strong>find</strong>:返回触点在id数组中对应的值.</li>
<li><strong>union</strong>:分别对p和q进行find操作，如果对应值相等不做操作，不相等则<strong>遍历</strong>id数组，将所有与p的对应值相等的id值改为q的id值.</li>
</ol>
<ul>
<li><strong>quick-union</strong>:改变id数组的定义，每个触点所对应的id元素都是同一个分量中另一个触点的名称，这种联系称为<strong>链接</strong>.由一个触点的链接一直跟随下去一定会到达<strong>根触点</strong>，即链接指向子集的触点.当且仅当两个触点的根触点相同时它们存在于同一个连通分量中.</li>
</ul>
<ol>
<li><strong>find</strong>:返回一个触点链接的根触点.</li>
<li><strong>union</strong>:分别对p和q进行find操作，如果对应值相等不做操作，不相等则将p的根触点链接到q的根触点上.</li>
</ol>
<ul>
<li><strong>加权quick-union</strong>:为了防止树极度不均衡，记录每一棵树的大小并总是将较小的树连接到较大的树上.在程序中引入size数组记录各个触点的根节点所对应的分量的大小.</li>
</ul>
<ol>
<li><strong>find</strong>:返回一个触点链接的根触点.</li>
<li><strong>union</strong>:分别对p和q进行find操作，如果对应值相等不做操作，不相等则判断对应值的根节点分量的大小，将小树的根触点链接到大树的根触点上.</li>
</ol>
<ul>
<li><strong>路径压缩</strong>:为find函数添加一个循环，将在路径上遇到的所有节点都直接链接到根节点.</li>
<li>关于并查集，可以参考<a href="http://www.cnblogs.com/noKing/p/8018609.html">这篇文章</a>.</li>
</ul>
<h2 id="chapter-2-排序">chapter 2 排序</h2>
<h3 id="21-初级排序算法">2.1 初级排序算法</h3>
<ul>
<li>
<p>排序算法类的模板</p>
<p><strong>less()</strong> 方法对元素进行比较，<strong>exch()</strong> 方法将元素交换位置。</p>
<pre><code class="language-java">public class Example{
    public static void sort(Comparable[] a){
        /* 排序算法 */
    }
	private static boolean less(Comparable v， Comparable w) {
       return (v.compareTo(w) &lt; 0);
    }
	private static void exch(Comparable[] a， int i， int j) {
   		Comparable swap = a[i];
   		a[i] = a[j];
   		a[j] = swap;
	}
    private static void show(Comparable[] a){
        for (int i = 0; i &lt; a.length; i++)
            StdOut.println(a[i] + &quot; &quot;);
        StdOut.println();
    }
    public static boolean isSorted(Comparable[] a){
        // 测试数组元素是否有序
        for (int i = 1; i &lt; a.length; i++)
            if (less(a[i]， a[i-1])) return false;
        return true;
    }
    public static void main(String[] args){
        String[] a = In.readStrings();
        sort(a);
        isSorted(a);
        show(a);
    }
}
</code></pre>
</li>
<li>
<p>排序算法可以分为两类：1️⃣ 除了函数调用所需的栈和固定数目的实例变量之外无需额外内存的原地排序算法；2️⃣ 需要额外内存空间来存储另一份数组副本的其他排序算法。</p>
</li>
<li>
<p><strong>选择排序：</strong> 首先找到数组中最小的元素，其次，将它和数组的第一个元素交换位置（如果第一个元素就是最小元素那么就和他自己交换）。再次，在剩下的元素中找到最小的元素，将它和数组的第二个元素交换位置。如此往复，直到将整个数组排序。</p>
<pre><code class="language-java">public Selection() {
    public static void sort(Comparable[] a) {
        int n = a.length;	//数组长度
        for (int i = 0; i &lt; n; i++) {
            // 将a[i]和a[i+1..N]中最小的元素交换
            int min = i;
            for (int j = i+1; j &lt; n; j++) {
                if (less(a[j]， a[min])) min = j;
            }
            exch(a， i， min);
        }
    }
}
</code></pre>
<p>对于长度为N的数组，选择排序需要大约<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>N</mi><mn>2</mn></msup><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">N^2/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord">2</span></span></span></span> 次比较和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 次交换。</p>
</li>
<li>
<p><strong>插入排序：</strong> 将每一张元素插入到其他已经有序的元素中的适当位置。在计算机的实现中，为了给要插入的元素腾出空间，我们需要将其余所有元素在插入之前都向右移动一位。</p>
<pre><code class="language-java">public class Insertion {
    public static void sort(Comparable[] a) {
        int n = a.length;
        for (int i = 1; i &lt; n; i++) {	//左边已经有序，通过比较将元素找个位置插入
            /*例如i=5时，a[0]到a[4]是有序的，比较a[5]和a[4]，如果a[5]比a[4]大，循环终止；如果a[5]比a[4]小，进入for循环，交换a[5]和a[4]；继续，j--，即比较a[4]和a[3]，以此类推；最后将原始的a[5]插入到合适位置；等效于比a[5]大的元素都会向右移动一位*/
            for (int j = i; j &gt; 0 &amp;&amp; less(a[j]， a[j-1]); j--) {
                exch(a， j， j-1);
            }
            assert isSorted(a， 0， i);
        }
        assert isSorted(a);
    }
}
</code></pre>
<p>对于随机排列的长度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 且主键不重复的数组，平均情况下插入排序需要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∼</mo><msup><mi>N</mi><mn>2</mn></msup><mi mathvariant="normal">/</mi><mn>4</mn></mrow><annotation encoding="application/x-tex">\sim N^2/4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord">4</span></span></span></span> 次比较以及<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∼</mo><msup><mi>N</mi><mn>2</mn></msup><mi mathvariant="normal">/</mi><mn>4</mn></mrow><annotation encoding="application/x-tex">\sim N^2/4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord">4</span></span></span></span>次交换。最坏情况下需要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∼</mo><msup><mi>N</mi><mn>2</mn></msup><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">\sim N^2/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord">2</span></span></span></span>次比较和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∼</mo><msup><mi>N</mi><mn>2</mn></msup><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">\sim N^2/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord">2</span></span></span></span>次交换，最好情况下需要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">N-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>次比较和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>次交换。</p>
</li>
<li>
<p><strong>倒置</strong>指的是数组中的两个顺序颠倒的元素。比如 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mi>X</mi><mi>A</mi><mi>M</mi><mi>P</mi><mi>L</mi><mi>E</mi></mrow><annotation encoding="application/x-tex">EXAMPLE</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span> 中有11对倒置：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mo>−</mo><mi>A</mi><mi mathvariant="normal">、</mi><mi>X</mi><mo>−</mo><mi>A</mi><mi mathvariant="normal">、</mi><mi>X</mi><mo>−</mo><mi>M</mi><mi mathvariant="normal">、</mi><mi>X</mi><mo>−</mo><mi>P</mi><mi mathvariant="normal">、</mi><mi>X</mi><mo>−</mo><mi>L</mi><mi mathvariant="normal">、</mi><mi>X</mi><mo>−</mo><mi>E</mi><mi mathvariant="normal">、</mi><mi>M</mi><mo>−</mo><mi>L</mi><mi mathvariant="normal">、</mi><mi>M</mi><mo>−</mo><mi>E</mi><mi mathvariant="normal">、</mi><mi>P</mi><mo>−</mo><mi>L</mi><mi mathvariant="normal">、</mi><mi>P</mi><mo>−</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">E-A、X-A、X-M、X-P、X-L、X-E、M-L、M-E、P-L、P-E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">A</span><span class="mord cjk_fallback">、</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">A</span><span class="mord cjk_fallback">、</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord cjk_fallback">、</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord cjk_fallback">、</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">L</span><span class="mord cjk_fallback">、</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord cjk_fallback">、</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">L</span><span class="mord cjk_fallback">、</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord cjk_fallback">、</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">L</span><span class="mord cjk_fallback">、</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span>以及<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mo>−</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">L-E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span> 。如果数组中倒置的数量小于数组大小的某个倍数，那么我们说这个数组是<strong>部分有序</strong>的。</p>
<p>几种典型的<strong>部分有序</strong>的数组：1️⃣ 数组中每个元素距离它们的最终位置都不远；2️⃣ 一个有序的大数组借一个小数组；3️⃣ 数组中只有几个元素的位置不正确。</p>
</li>
<li>
<p>插入排序需要的交换操作和数组中倒置的数量相同，需要的比较次数大于等于倒置的数量，小于等于倒置的数量加上数组的大小再减一。</p>
</li>
<li>
<p>要大幅提高插入排序的速度，只需要在内循环中将较大的元素都向右移动而不总是交换两个元素（这样访问数组的次数就能减半）。</p>
</li>
<li>
<p><strong>希尔排序</strong> 的思想是使数组中间隔为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span></span></span></span> 的元素都是有序的。这样的数组被称为<strong>h有序数组</strong>。在进行排序时，如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span></span></span></span>很大，就能将元素移动到很远的地方，为实现更小的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span></span></span></span>有序创造方便。用这种方式，对于任意以1结尾的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span></span></span></span>序列，就能够将数组排序，这就是<strong>希尔排序</strong>。</p>
<pre><code class="language-java">public class Shell {
    /**
     * Rearranges the array in ascending order， using the natural order.
     * @param a the array to be sorted
     */
    public static void sort(Comparable[] a) {
        int n = a.length;
        int h = 1;
        /* 3x+1 increment sequence:  1， 4， 13， 40， 121， 364， 1093， ... */
        while (h &lt; n/3) h = 3*h + 1; 
        while (h &gt;= 1) {
            // h-sort the array
            for (int i = h; i &lt; n; i++) {
                for (int j = i; j &gt;= h &amp;&amp; less(a[j]， a[j-h]); j -= h) {
                    exch(a， j， j-h);
                }
            }
            assert isHsorted(a， h); 
            h /= 3;
        }
        assert isSorted(a);
    }
}
</code></pre>
<p>需要解决一个排序问题而有没有系统排序函数可用时，可以先用希尔排序，然后再考虑是否值得将它替换为更加复杂的排序算法。对于中等大小的数组，它的运行时间是可以接受的，而且代码量小又不需要额外的内存空间。而更加复杂的代码对于很大的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> ，可能只会比希尔排序快两倍（可能还达不到）。</p>
</li>
</ul>
<h3 id="22-归并排序">2.2 归并排序</h3>
<ul>
<li>
<p>**归并：**将两个有序的数组归并成一个更大的有序数组。</p>
</li>
<li>
<p>归并排序：要将一个数组排序，可以先（递归地）将它分成两半分别排序，然后将结果归并起来。归并排序可以保证将任意长度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 的数组排序所需时间和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">NlogN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 成正比，重要缺点是它所需的额外内存空间和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>成正比。</p>
</li>
<li>
<p><strong>原地归并的抽象方法</strong></p>
<pre><code class="language-java">private static void merge(Comparable[] a， Comparable[] aux， int lo， int mid， int hi) {
        // precondition: a[lo .. mid] and a[mid+1 .. hi] are sorted subarrays
        assert isSorted(a， lo， mid);
        assert isSorted(a， mid+1， hi);

        // copy to aux[]
        for (int k = lo; k &lt;= hi; k++) {
            aux[k] = a[k]; 
        }
        // merge back to a[]
        int i = lo， j = mid+1;
        for (int k = lo; k &lt;= hi; k++) {
            if      (i &gt; mid)              a[k] = aux[j++];
            else if (j &gt; hi)               a[k] = aux[i++];
            else if (less(aux[j]， aux[i])) a[k] = aux[j++];
            else                           a[k] = aux[i++];
        }
</code></pre>
</li>
<li>
<p>自顶向下的归并排序：<strong>分治思想</strong>的最典型例子。如果它能够将两个子数组排序，他就能够通过归并两个子数组来将整个数组排序。</p>
<pre><code class="language-java">public class Merge{
    private static Comparable[] aux;	//	归并所需的辅助数组
    public static void sort(Comparable[] a) {
        aux = new Comparable[a.length];
        sort(a， aux， 0， a.length-1);
        assert isSorted(a);
    }
    private static void sort(Comparable[] a， Comparable[] aux， int lo， int hi) {
        if (hi &lt;= lo) return;
        int mid = lo + (hi - lo) / 2;
        sort(a， aux， lo， mid);	//将左半边排序
        sort(a， aux， mid + 1， hi);	//将右半边排序
        merge(a， aux， lo， mid， hi);	//归并结果（“原地归并的抽象方法”）
    }
}
</code></pre>
<p>对于长度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>的任意数组，自顶向下的归并排序需要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mn>2</mn><mi>N</mi><mi>l</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">1/2NlgN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 至<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mi>l</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">NlgN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 次比较，最多需要访问数组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>6</mn><mi>N</mi><mi>l</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">6NlgN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">6</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 次。</p>
</li>
<li>
<p>自底向上的归并排序：首先我们进行的是两两归并（把每个元素想象成一个大小为1的数组），然后是四四归并（将两个大小为2的数组归并成一个有4个元素的数组），然后是八八的归并，一直下去。在每一轮归并中，最后一次归并的第二个子数组可能比第一子数组要小（但这对<strong>merge()</strong> 方法不是问题）</p>
<pre><code class="language-java">public class MergeBU {
    public static void sort(Comparable[] a) {
        int n = a.length;
        Comparable[] aux = new Comparable[n];
        for (int len = 1; len &lt; n; len *= 2) {
            for (int lo = 0; lo &lt; n-len; lo += len+len) {
                int mid  = lo+len-1;
                int hi = Math.min(lo+len+len-1， n-1);
                merge(a， aux， lo， mid， hi);
            }
        }
        assert isSorted(a);
    }
}
</code></pre>
<p>对于长度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>的任意数组，自顶向下的归并排序需要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mn>2</mn><mi>N</mi><mi>l</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">1/2NlgN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 至<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mi>l</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">NlgN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 次比较，最多需要访问数组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>6</mn><mi>N</mi><mi>l</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">6NlgN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">6</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 次。</p>
<p><strong>当数组长度为2的幂次时</strong>，自顶向下和自底向上的归并排序所用的比较次数和数组访问次数正好相同，只是顺序不同。</p>
</li>
<li>
<p>自底向上的归并排序比较适合用<strong>链表</strong>组织的数据。将链表先按大小为1的子链表进行排序，然后时大小为2的子链表，然后是大小为4的子链表等。这种方法只需要重新组织链表链接就能将链表<strong>原地排序</strong>（不需要创建任何新的链表结点）。</p>
</li>
<li>
<p>问：当数组中存在重复的元素时归并排序的表现如何？</p>
<p>答：如果所有的元素都相同，那么归并排序的运行时间将是线性的（需要一个额外的测试避免归并已经有序的数组）。但如果有多个不同的重复值，这样做的性能收益就不是很明显了。例如，假设输入数组的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>个技术位上的元素都是同一个值，另外<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>个偶数位上的元素都是另一个值，此时算法的运行时间就是线性对数的（这样的数组和所有元素都不重复的数组满足了相同的循环条件），而非线性的。</p>
</li>
</ul>
<h3 id="23-快速排序">2.3 快速排序</h3>
<ul>
<li>
<p><strong>快速排序</strong>:时间复杂度为<strong>O(NlogN)</strong>。将一个数组<strong>随机打乱</strong>(防止出现最坏情况)，然后通过<strong>切分</strong>变为两个子数组，将两部分独立地排序，使得切分点左边的所有元素都不大于它，右边的所有元素都不小于它。<strong>递归</strong>地进行这一过程。</p>
<pre><code class="language-java">public class Quick {
    /**
     * Rearranges the array in ascending order， using the natural order.
     * @param a the array to be sorted
     */
    public static void sort(Comparable[] a) {
        StdRandom.shuffle(a);
        sort(a， 0， a.length - 1);
        assert isSorted(a);
    }

    // quicksort the subarray from a[lo] to a[hi]
    private static void sort(Comparable[] a， int lo， int hi) { 
        if (hi &lt;= lo) return;
        int j = partition(a， lo， hi);
        sort(a， lo， j-1);
        sort(a， j+1， hi);
        assert isSorted(a， lo， hi);
    }
}
</code></pre>
</li>
<li>
<p><strong>切分</strong>:一般策略是随意取a[low]作为<strong>切分元素</strong>，然后从数组的左端向右扫描，找到一个大于等于它的元素，再从数组的右端向左扫描，找到一个小于等于它的元素，交换它们的位置。如此继续，直到两个指针<strong>相遇</strong>时，将切分元素**a[low]<strong>和左子数组最右侧的元素</strong>a[j]**交换然后返回 <strong>j</strong>。</p>
<pre><code class="language-java">// partition the subarray a[lo..hi] so that a[lo..j-1] &lt;= a[j] &lt;= a[j+1..hi]
private static int partition(Comparable[] a， int lo， int hi) {
    int i = lo， j = hi + 1;
    Comparable v = a[lo];
    while (true) { 
        // find item on lo to swap
        while (less(a[++i]， v))	if (i == hi) break;

        // find item on hi to swap
        while (less(v， a[--j]))	if (j == lo) break;
        // check if pointers cross
        if (i &gt;= j) break;
        exch(a， i， j);
    }
    // put partitioning item v at a[j]
    exch(a， lo， j);
    // now， a[lo .. j-1] &lt;= a[j] &lt;= a[j+1 .. hi]
    return j;
}
</code></pre>
</li>
<li>
<p><strong>改进</strong>:</p>
</li>
</ul>
<ol>
<li>
<p>当子数组较小时(比如长度小于15)使用<strong>插入排序</strong></p>
<pre><code class="language-java">if (hi &lt;= lo + M) {Insertion.sort(a， lo， hi); return;}
</code></pre>
</li>
<li>
<p>取子数组的一小部分元素(比如3个)的<strong>中位数</strong>来切分数组，还可以将切分元素放在数组末尾作为<strong>哨兵</strong>来去掉数组边界测试.</p>
</li>
<li>
<p>如果数组含有<strong>大量重复</strong>元素，可以采用<strong>三向切分</strong>的办法，将数组分为小于切分元素，等于切分元素和大于切分元素三部分，它将排序时间降到了<strong>线性</strong>级别.</p>
<pre><code class="language-java">public class Quick3way {
    // quicksort the subarray a[lo .. hi] using 3-way partitioning
    private static void sort(Comparable[] a， int lo， int hi) { 
        if (hi &lt;= lo) return;
        int lt = lo， gt = hi;
        Comparable v = a[lo];
        int i = lo + 1;
        while (i &lt;= gt) {
            int cmp = a[i].compareTo(v);
            if      (cmp &lt; 0) exch(a， lt++， i++);
            else if (cmp &gt; 0) exch(a， i， gt--);
            else              i++;
        }
        // a[lo..lt-1] &lt; v = a[lt..gt] &lt; a[gt+1..hi]. 
        sort(a， lo， lt-1);
        sort(a， gt+1， hi);
        assert isSorted(a， lo， hi);
    }
}
</code></pre>
</li>
</ol>
<h3 id="24-优先队列">2.4 优先队列</h3>
<ul>
<li>
<p><strong>优先队列：<strong>一种支持</strong>删除最大元素</strong>和<strong>插入元素</strong>的数据结构。</p>
</li>
<li>
<p>从N个输入中找到最大的M个元素所需成本呢</p>
<table>
<thead>
<tr>
<th></th>
<th><strong>增长的数量级</strong></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>时间</td>
<td>空间</td>
</tr>
<tr>
<td>排序算法的用例</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">Nlog N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span></td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span></td>
</tr>
<tr>
<td>调用初级实现的优先队列</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mi>M</mi></mrow><annotation encoding="application/x-tex">NM</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span></td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span></td>
</tr>
<tr>
<td>调用基于堆实现的优先队列</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>M</mi></mrow><annotation encoding="application/x-tex">Nlog M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span></td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span></td>
</tr>
</tbody>
</table>
</li>
<li>
<p>优先队列的各种实现在最坏情况下运行时间的增长数量级</p>
<table>
<thead>
<tr>
<th>数据结构</th>
<th>插入元素</th>
<th>删除最大元素</th>
</tr>
</thead>
<tbody>
<tr>
<td>有序数组</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span></td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></td>
</tr>
<tr>
<td>无序数组</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span></td>
</tr>
<tr>
<td>堆</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">logN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span></td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">log N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span></td>
</tr>
<tr>
<td>理想情况</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></td>
</tr>
</tbody>
</table>
</li>
<li>
<p>当一颗二叉树的每个结点都大于等于它的两个子结点时，它被称为<strong>堆有序</strong>。<strong>根结点</strong>时堆有序的二叉树的<strong>最大结点</strong>。</p>
</li>
<li>
<p><strong>二叉堆</strong> 是一组能够用堆有序的完全二叉树排序的元素，并在数组中按照层级存储（为了方便，不使用数组中的第一个位置）。</p>
</li>
<li>
<p>在一个堆中，位置 <strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span></strong> 的结点的父结点的位置为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⌊</mo><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>⌋</mo></mrow><annotation encoding="application/x-tex">\lfloor k/2 \rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">⌋</span></span></span></span> ，而它的两个子结点的位置则分别为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>k</mi></mrow><annotation encoding="application/x-tex">2k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2k+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。这样就可以通过计算数组的索引在树中上下移动：从 <strong>a[k]</strong> 向上一层就令 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 等于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">k/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span></span></span></span>，向下一层则令 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 等于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>k</mi></mrow><annotation encoding="application/x-tex">2k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 或 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2k+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。</p>
</li>
<li>
<p>一颗大小为<em>N</em>的完全二叉树的高度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⌊</mo><mi>l</mi><mi>g</mi><mi>N</mi><mo>⌋</mo></mrow><annotation encoding="application/x-tex">\lfloor lgN \rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">⌋</span></span></span></span>。</p>
</li>
<li>
<p>堆的操作会进行一些简单的改动，打破堆的状态，然后再遍历堆并按照要求将堆的状态恢复。我们称为<strong>堆的有序化</strong>。</p>
</li>
<li>
<p><strong>由下至上的堆有序化(上浮)</strong> ：如果堆的有序状态因为某个结点变得比它的父结点<strong>更大</strong>而被打破，就需要交换它和它的父结点。位置<strong>k</strong>的结点的父结点的位置是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⌊</mo><mrow><mi mathvariant="bold">k</mi><mi mathvariant="bold">/</mi><mn mathvariant="bold">2</mn></mrow><mo>⌋</mo></mrow><annotation encoding="application/x-tex">\lfloor \bold{k/2} \rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mord mathbf">k</span><span class="mord mathbf">/</span><span class="mord mathbf">2</span></span><span class="mclose">⌋</span></span></span></span>。重复这个过程直到它不再大于它的父结点为止。</p>
<pre><code class="language-java">private void swim(int k){
    while (k &gt; 1 &amp;&amp; less(k/2， k)){
        exch(k/2， k);
        k = k/2;
    }
}
</code></pre>
</li>
<li>
<p><strong>由上至下的堆有序化(下沉)</strong>:如果堆的有序状态因为某个结点变得比它的父结点<strong>更小</strong>而被打破，可以通过交换它和它的两个子结点中的较大者来恢复堆。位置<strong>k</strong>的结点的子结点为<strong>2k</strong>和<strong>2k+1</strong>。重复这个过程直到它的子结点都比它更小或是到达了堆的底部为止。</p>
<pre><code class="language-java">private void sink(int k){
    while (2*k &lt;= N){
        int j = 2*k;
        if (j &lt; N &amp;&amp; less(j， j+1))	j++;
        if (!less(k， j))	break;
        exch(k， j);
        k = j;
    }
}
</code></pre>
</li>
<li>
<p><strong>插入元素</strong>:将新元素加到末尾，增加堆的大小并让新元素<strong>上浮</strong>到合适的位置.</p>
</li>
<li>
<p><strong>删除最大元素</strong>:从堆顶删去最大的元素，并将最后一个元素放到顶端，减小堆的大小并让这个元素<strong>下沉</strong>到合适的位置。</p>
</li>
<li>
<p>对于一个含有<em>N</em>个元素的基于堆的优先队列，<strong>插入元素</strong>操作只需不超过<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>l</mi><mi>g</mi><mi>N</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(lgN+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>次比较。删除最大元素的操作需要不超过<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>l</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">2lgN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>次比较。</p>
</li>
<li>
<p>使用基于堆的优先队列，将所有元素插入一个查找最小元素的优先队列，然后在重复调用删除最小元素的操作来将它们按照顺序删去，即为<strong>堆排序</strong>。</p>
</li>
<li>
<p><strong>堆排序</strong>: 1️⃣ <strong>构造</strong>:从数组的<strong>中间元素</strong>开始，从右到左地对每个元素用<strong>下沉</strong>方法构造子堆。2️⃣ <strong>排序</strong>:将最大的元素a[1]和末尾元素a[N]交换，将堆的大小-1，并对交换到堆顶的<strong>末尾元素</strong>使用<strong>下沉</strong>来修复堆，直到堆变空，此时数组中的元素已经有序。</p>
<pre><code class="language-java">public static void sort(Comparable[] a){
    int N = a.length;
    for (int k = N/2; K &gt;= 1; k--)	sink(a， k， N);
    while (N &gt; 1){
        exch(a， 1， N--);
        sink(a， 1， N);
    }
}
</code></pre>
</li>
<li>
<p>用下沉操作由 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 个元素构造堆只需要少于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>N</mi></mrow><annotation encoding="application/x-tex">2N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 次比较和少于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 次交换。而用上浮操作，从左到右遍历数组的时间复杂度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(NlogN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>。</p>
</li>
<li>
<p>因为大多数在下沉排序期间重新插入堆的元素会被直接加入到堆底，所以可以使用<strong>先下沉后上浮</strong>的方法优化，即直接提升较大的子结点直至到达堆底，然后再使元素上浮到正确的位置。</p>
</li>
</ul>
<h3 id="25-应用">2.5 应用</h3>
<ul>
<li>
<p>插入排序和归并排序是<strong>稳定</strong>的，即不会改变重复元素的相对位置。选择排序、希尔排序、快速排序和堆排序则不是稳定的.</p>
</li>
<li>
<p>快速排序是最快的通用排序算法。</p>
</li>
<li>
<p>各种排序算法性能特点</p>
<table>
<thead>
<tr>
<th>算法</th>
<th>稳定性</th>
<th>是否原地排序</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>选择排序</td>
<td>不稳定</td>
<td>是</td>
<td>$ N^2 $</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></td>
<td></td>
</tr>
<tr>
<td>插入排序</td>
<td>稳定</td>
<td>是</td>
<td>介于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>N</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">N^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></td>
<td>取决于输入元素的排列情况</td>
</tr>
<tr>
<td>希尔排序</td>
<td>不稳定</td>
<td>是</td>
<td>$NlogN?  $ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>N</mi><mrow><mn>6</mn><mi mathvariant="normal">/</mi><mn>5</mn></mrow></msup><mo>?</mo></mrow><annotation encoding="application/x-tex">N^{6/5}?</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8879999999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mord mtight">/</span><span class="mord mtight">5</span></span></span></span></span></span></span></span></span><span class="mclose">?</span></span></span></span></td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>快速排序</td>
<td>不稳定</td>
<td>是</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">N logN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span></td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">lg N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span></td>
<td>运行效率由概率提供保证</td>
</tr>
<tr>
<td>三向快速排序</td>
<td>不稳定</td>
<td>是</td>
<td>介于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">N logN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span></td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">lg N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span></td>
<td>运行效率由概率提供保证，同时取决于输入元素的分布情况。</td>
</tr>
<tr>
<td>归并排序</td>
<td>稳定</td>
<td>否</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">NlogN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span></td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span></td>
<td></td>
</tr>
<tr>
<td>堆排序</td>
<td>不稳定</td>
<td>是</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">NlogN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span></td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></td>
<td></td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>归约</strong>:为解决某个问题而发明的算法正好可以用来解决另一种问题</p>
</li>
</ul>
<ol>
<li><strong>找出重复元素</strong>:首先将数组排序，然后遍历有序的数组，记录连续出现的重复元素即可.</li>
<li><strong>排名</strong>:求两组数列的Kendall tau距离，即在两组排列中相对顺序不同的数字组数.某个排列和标准排列的Kendall tau距离就是其中逆序数对的数量.可以由其中一个排列确定一个标准索引，然后以这个标准索引为标准对两组数列进行<strong>归并排序</strong>，移动的次数即为Kendall tau距离.</li>
<li><strong>查找中位数</strong>:使用<strong>快速排序的分割算法</strong>，当切分点j小于N/2时只用切分右数组，切分点j大于2/N时只用切分左数组，切分点j=N/2时a[j]即为中位数.如果是<strong>海量数据</strong>，则可以将数据用二进制表示，根据最大位是0或1划分为两个文件，然后不断对包含中位数的那个文件做此操作，直到可以将剩余的数全部读进内存时再使用快速排序.</li>
</ol>
<h2 id="chapter-3-查找">chapter 3 查找</h2>
<h3 id="31-符号表">3.1 符号表</h3>
<ul>
<li>
<p><strong>符号表</strong> 是一种存储键值对的数据结构，有时也被称为<strong>字典</strong> 或<strong>索引</strong>。支持两种操作：<strong>插入(put)</strong>，即将一组新的键值对存入表中；<strong>查找(get)</strong>，即根据给定的键得到相应的值。</p>
</li>
<li>
<p>符号表的实现遵循的规则：1️⃣ 每个键只对应着一个值（表中不允许存在重复的键）。2️⃣ 当用例代码向表中存入的键值对和表中已有的键（及关联的值）冲突时，新的值会替代旧的值。</p>
</li>
<li>
<p>在符号表中，删除的实现有两种方式：1️⃣ <strong>延时删除</strong>，就是将键对应的值置为空(null)，然后在某个时候删去所有值为空的键；2️⃣ <strong>即时删除</strong>，就是立刻从表中删除指定的键。</p>
</li>
<li>
<p>对于符号表的简单实现（无序），用例的输出中键的顺序是不确定的；对于有序符号表，用例应该就键按顺序打印出来，这是一种<strong>索引用例</strong>。</p>
</li>
<li>
<p>符号表中使用的数据结构的一个简单选择是<strong>链表</strong>，每个结点存储一个键值对。在查找中我们一个一个地顺序遍历符号表中的所有键并使用<strong>equals()<strong>方法来寻找与被查找的键匹配的值，这叫</strong>顺序查找</strong>。</p>
<pre><code class="language-java">public class SequentialSearchST&lt;Key， Value&gt;{
    private Node first;	//链表首结点
    private class Node{
        Key key;
        Value val;
        Node next;
        public Node(Key key， Value val， Node next){
            this.key = key;
            this.val = val;
            this.next = next;
    	}
    }
    public Value get(Key key){
        for (Node x = first; x != null; x = x.next)
            if (key.equals(x.key))	return x.val;
        return null;
    }
    public void put(Key key， Value val){
        for (Node x = first; x != null; x = x.next)
            if (key.equals(x.key)){
                x.val = val;	return;		//命中，更新
            }
        first = new Node(key， val， first);	//	未命中，新建结点
    }
    
}
</code></pre>
<p>在含有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>对键值的基于（无序）链表的符号表中，未命中的查找和插入操作都需要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>次比较。命中的查找在最坏情况下需要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>次比较，特别地，向一个空表中插入<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>个不同的键需要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∼</mo><msup><mi>N</mi><mn>2</mn></msup><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">\sim N^2/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord">2</span></span></span></span>次比较。</p>
</li>
<li>
<p>有序符号表使用的数据结构是<strong>一对平行的数组</strong>，一个存储键一个存储值。核心是**rank()**方法，**rank()**方法能够精确地告诉我们到哪里去更新它的值，以及当键不在表中时将键存储到表的何处。</p>
</li>
<li>
<p><strong>递归的二分查找rank()方法：</strong></p>
<pre><code class="language-java">public int rank(Key key， int lo， int hi){
	if (hi &lt; lo) return lo;	//	未查到到，返回插入的位置
    int mid = lo + (hi - lo) / 2;
    int cmp = key.compareTo(Keys[mid]);
    if (cmp &lt; 0) return rank(key， lo， mid-1);
    else if (cmp &gt; 0) return rank(key， mid+1， hi);
    else return mid;
}
</code></pre>
</li>
<li>
<p><strong>迭代的二分查找rank()方法：</strong></p>
<pre><code class="language-java">public int rank(Key key){
    int lo = 0， hi = N - 1;
    while (lo &lt; hi){
        int mid = lo + (hi - lo) / 2;
        int cmp = key.compareTo(keys[mid]);
        if (cmp &lt; 0) hi = mid - 1;
        else if (cmp &gt; 0) lo = mid + 1;
        else return mid;
    }
    return lo;
}
</code></pre>
</li>
<li>
<p><strong>二分查找(基于有序数组)</strong></p>
<pre><code class="language-java">public class BinarySearchST&lt;Key extends Comparable&lt;Key&gt;， Value&gt; {
    private Key[] keys;
    private Value[] vals;
    private int N;
    
    public BinarySearchST(int capacity) { 
        keys = (Key[]) new Comparable[capacity]; 
        vals = (Value[]) new Object[capacity]; 
    }   

    public int size() {
        return N;
    }

    public Value get(Key key) {
        if (key == null) throw new IllegalArgumentException(&quot;argument to get() is null&quot;); 
        if (isEmpty()) return null;
        int i = rank(key); 
        if (i &lt; n &amp;&amp; keys[i].compareTo(key) == 0) return vals[i];
        return null;
    } 

    public int rank(Key key) {  
    } 

    public void put(Key key， Value val)  {
        if (key == null) throw new IllegalArgumentException(&quot;first argument to put() is null&quot;); 
        int i = rank(key);
        // key is already in table
        if (i &lt; N &amp;&amp; keys[i].compareTo(key) == 0) {
            vals[i] = val;
            return;
        }
        
        for (int j = N; j &gt; i; j--)  {	//将所有更大的键向后移动一格来腾出位置
            keys[j] = keys[j-1];
            vals[j] = vals[j-1];
        }
        keys[i] = key;	//并将给定的键值对分别插入到各自的合适位置
        vals[i] = val;
        n++;
    } 
}
</code></pre>
<p>在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>个键的有序数组中进行二分查找最多需要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>l</mi><mi>g</mi><mi>N</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(lgN+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>次比较（无论是否成功）；</p>
<p>二分查找虽然减少了比较的次数但无法减少运行的时间，因为：在键时随机排列的情况下，构造一个基于有序数组的符号表所需要访问数组的次数是数组长度的平方级别。</p>
</li>
<li>
<p><strong>符号表的各种实现的优缺点：</strong></p>
<table>
<thead>
<tr>
<th>使用的数据结构</th>
<th>实现</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>链表（顺序查找）</td>
<td>SequentialSearchST</td>
<td>适用于小型问题</td>
<td>对于大型符号表很慢</td>
</tr>
<tr>
<td>有序数组二分查找</td>
<td>BinarySearchST</td>
<td>最优的查找效率和空间需求，能够进行有序性相关的操作</td>
<td>插入操作很慢</td>
</tr>
<tr>
<td>二叉查找树</td>
<td>BST</td>
<td>实现简单，能够进行有序性相关的操作</td>
<td>没有性能上界的保证，链接需要额外的空间</td>
</tr>
<tr>
<td>平衡二叉查找树</td>
<td>RedBlackBST</td>
<td>最优的查找和插入效率，能够及逆行有序性相关的操作</td>
<td>链接需要额外的空间</td>
</tr>
<tr>
<td>散列表</td>
<td>SeparateChainHashST LInearProbingHashST</td>
<td>能够快速的查找和插入常见类型的数据</td>
<td>需要计算每种类型的数据的散列，无法进行相关性相关的操作，链接和空结点需要额外的空间</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h3 id="32-二叉查找树">3.2 二叉查找树</h3>
<ul>
<li>
<p>一棵<strong>二叉查找树(BST)<strong>是一棵二叉树，其中每个结点都含有一个Comparable的</strong>键</strong>以及<strong>值</strong>，且每个结点的键都<strong>大于</strong>其<strong>左子树</strong>中的任意结点的键而<strong>小于</strong>其<strong>右子树</strong>的任意结点的键。</p>
</li>
<li>
<p>每个结点还会有一个<strong>结点计数器</strong>，它给出了以该结点为根的子树的结点总数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold">s</mi><mi mathvariant="bold">i</mi><mi mathvariant="bold">z</mi><mi mathvariant="bold">e</mi><mo>(</mo><mi mathvariant="bold">x</mi><mo>)</mo><mo>=</mo><mi mathvariant="bold">s</mi><mi mathvariant="bold">i</mi><mi mathvariant="bold">z</mi><mi mathvariant="bold">e</mi><mo>(</mo><mi mathvariant="bold">x</mi><mi mathvariant="bold">.</mi><mi mathvariant="bold">l</mi><mi mathvariant="bold">e</mi><mi mathvariant="bold">f</mi><mi mathvariant="bold">t</mi><mo>)</mo><mo>+</mo><mi mathvariant="bold">s</mi><mi mathvariant="bold">i</mi><mi mathvariant="bold">z</mi><mi mathvariant="bold">e</mi><mo>(</mo><mi mathvariant="bold">x</mi><mi mathvariant="bold">.</mi><mi mathvariant="bold">r</mi><mi mathvariant="bold">i</mi><mi mathvariant="bold">g</mi><mi mathvariant="bold">h</mi><mi mathvariant="bold">t</mi><mo>)</mo><mo>+</mo><mn mathvariant="bold">1</mn></mrow><annotation encoding="application/x-tex">\bold{size(x)=size(x.left)+size(x.right)+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathbf">s</span><span class="mord mathbf">i</span><span class="mord mathbf">z</span><span class="mord mathbf">e</span><span class="mopen">(</span><span class="mord mathbf">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathbf">s</span><span class="mord mathbf">i</span><span class="mord mathbf">z</span><span class="mord mathbf">e</span><span class="mopen">(</span><span class="mord mathbf">x</span><span class="mord mathbf">.</span><span class="mord mathbf">l</span><span class="mord mathbf">e</span><span class="mord mathbf" style="margin-right:0.10903em;">f</span><span class="mord mathbf">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathbf">s</span><span class="mord mathbf">i</span><span class="mord mathbf">z</span><span class="mord mathbf">e</span><span class="mopen">(</span><span class="mord mathbf">x</span><span class="mord mathbf">.</span><span class="mord mathbf">r</span><span class="mord mathbf">i</span><span class="mord mathbf" style="margin-right:0.01597em;">g</span><span class="mord mathbf">h</span><span class="mord mathbf">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathbf">1</span></span></span></span></span></p>
</li>
<li>
<p>一棵二叉查找树代表了一组键的集合，而同一个集合可以用<strong>多颗不同</strong>的二叉查找树表示。如果将一棵二叉查找树的所有键按从左到右的顺序投影到一条直线上，那么会得到一条<strong>有序</strong>的键列。</p>
<pre><code class="language-java">public class BST&lt;Key extends Comparable&lt;Key&gt;， Value&gt;{
    private Node root;	//二叉查找树的根结点
    private class Node{
        private Key key;
        private Value val;
        private Node left， right;
        private int N;
        public Node(Key key， Value val， int N){
            this.key = key; this.val = val; this.N = N;
        }
    }
    public int size(){
        return size(root);
    }
    private int size(Node x){
        if (x == null) return 0;
        else return x.N;
    }
    public Value get(Key key){}
    
    public void put(Key key， Value val){}
    
}
</code></pre>
</li>
<li>
<p>用<strong>递归</strong>的方法<strong>查找</strong>: 1️⃣ 如果树是空的，则查找未命中；2️⃣ 如果被查找的键和根结点的键相等，查找命中；   3️⃣ 如果被查找的键小于根结点的键，我们就递归地在左子树中查找；4️⃣ 如果被查找的键大于根结点的键，我们就递归地在右子树中查找。</p>
</li>
<li>
<p><strong>插入</strong>：如果树是空的，就返回一个含有该键值对的新结点；如果被查找的键小于根结点的键，我们就继续在左子数中插入该键，否则在右子树中插入该键。</p>
<pre><code class="language-java">public Value get(Key key){
    return get(root， key);
}
private Value get(Node x， Key key){
    if (x == null) return null;
    int cmp = key.compareTo(x.key);
    if (cmp &lt; 0) return get(x.left， key);
    else if (cmp &gt; 0) return get(x.right， key);
    else return x.val;
}

public void put(Key key， Value val){
    root = put(rppt， key， val);
}
private Node put(Node x， Key key， Value val){
// 如果key存在于以x为根结点的子树中则更新它的值；否则以key和val为键值对的新结点插入到该子树中
    if (x == null) return new Node(key， val， 1);
    int cmp = key.compareTo(x.key);
    if (cmp &lt; 0) x.left = put(x.left， key， val);
    if (cmp &gt; 0) x.right = put(x.right， key， val);
    else x.val = val;
    x.N = size(x.left) + size(x.right) + 1;
    return x;
}
</code></pre>
</li>
<li>
<p>递归调用前的代码想象成沿着树向下走，递归调用后的代码想象成沿着数上爬。</p>
</li>
<li>
<p>在由<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>个随机键构造的二叉查找树中，查找命中平均所需的比较次数为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∼</mo><mn>2</mn><mi>l</mi><mi>n</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">\sim 2lnN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>(约<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1.39</mn><mi>l</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">1.39lgN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">3</span><span class="mord">9</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>)；插入操作和查找为未命中平均所需的比较次数为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∼</mo><mn>2</mn><mi>l</mi><mi>n</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">\sim 2lnN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>(约<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1.39</mn><mi>l</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">1.39lgN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">3</span><span class="mord">9</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>)。</p>
</li>
<li>
<p>如果根结点的左链接为空，那么一颗二叉查找树中<strong>最小的键</strong>就是根结点；如果根结点的左链接非空，那么树中的<strong>最小键</strong>就是左子树中的最小键；<strong>最大键</strong>类似。</p>
</li>
<li>
<p>如果给定的键key小于二叉查找树的根结点的键，那么小于等于key的最大键floor(key)一定在根结点的左子树中；如果给定的键key大于二叉查找树的根结点，那么只有当根结点右子树中存在小于等于key的结点时，小于等于key的最大键才会出现在右子树中，否则根结点就是小于等于key的最大键。大于等于key的最小键ceiling(key类似)。</p>
<pre><code class="language-java">public Key min(){
    return min(root).key;
}
private Node min(Node x){
    if (x.left == null) return x;
    return min(x.left);
}
public Key floor(Key key){
    Node x = floor(root， key);
    if (x == null) return null;
    return x.key;
}
private Node floor(Node x， Key key){
    if (x == null) return null;
    int cmp = key.compareTo(x.key);
    if (cmp == 0) return x;
    if (cmp &lt; 0) return floor(x.left， key);
    Node t = floor(x.right， key);
    if (t != null) return t;
    else return x;
}
</code></pre>
</li>
<li>
<p><strong>排名</strong>也是<strong>递归</strong>实现的: 1️⃣ 如果给定的键和根结点的键相等，返回左子树的结点总数<strong>t</strong>；2️⃣ 如果给定的键小于根结点，返回该键在左子树中的排名；3️⃣ 如果给定的键大于根结点，返回<strong>t+1</strong>加上它在右子树中的排名。</p>
<pre><code class="language-java">/*二叉查找树中select()和rank()方法的实现*/
public Key select(int k){
    return select(root， k).key;
}
private Node select(Node x， int k){
    // 返回排名为K的结点
    if (x == null) return null;
    int t = size(x.left);
    if (t &gt; k) return select(x.left， k);
    else if (t &lt; k) return select(x.right， k-t-1);
    else return x;
}
public int rank(Key key){
   return rank（key， root);
}
private int rank(Key key， Node x){
    // 返回以x为根结点的子树中小于x.key的键的数量
    if (x == null) return 0;
    int cmp = key.compareTo(x.key);
    if (cmp &lt; 0) return rank(key， x.left);
    else if (cmp &gt; 0) return 1 + size(x.left) + rank(key， x.right);
    else return size(x.left);
}
</code></pre>
</li>
<li></li>
<li>
<p><strong>删除</strong>操作通过将x替换为它的<strong>后继结点</strong>(其右子树中的最小结点)完成。1️⃣ 将指向即将被删除结点的链接保存为<strong>t</strong>; 2️⃣ 将x指向它的后继结点min(t.right); 3️⃣ 将x的右链接指向删掉后继结点的原右子树; 4️⃣ 将x的左链接设为t.left; 5️⃣修改结点计数器的值。</p>
<pre><code class="language-java">public void deleteMin() {
    root = deleteMin(root);
}

private Node deleteMin(Node x) {
    if (x.left == null) return x.right;
    x.left = deleteMin(x.left);
    x.size = size(x.left) + size(x.right) + 1;
    return x;
}

public void deleteMax() {
    root = deleteMax(root);
}

private Node deleteMax(Node x) {
    if (x.right == null) return x.left;
    x.right = deleteMax(x.right);
    x.size = size(x.left) + size(x.right) + 1;
    return x;
}

public void delete(Key key) {
    root = delete(root， key);
}

private Node delete(Node x， Key key) {
    if (x == null) return null;
    int cmp = key.compareTo(x.key);
    if (cmp &lt; 0) x.left  = delete(x.left，  key);
    else if (cmp &gt; 0) x.right = delete(x.right， key);
    else { 
        if (x.right == null) return x.left;
        if (x.left  == null) return x.right;
        Node t = x;
        x = min(t.right);
        x.right = deleteMin(t.right);
        x.left = t.left;
    } 
    x.N = size(x.left) + size(x.right) + 1;
    return x;
}
</code></pre>
</li>
<li>
<p>使用<strong>中序遍历</strong>来进行<strong>范围查找</strong>，将符合条件的键放入一个队列，跳过不可能符合条件的子树。</p>
<pre><code class="language-java">public Iterable&lt;Key&gt; keys(){
    return keys(min()， max());
}
public Iterable&lt;Key&gt; keys(Key lo， Key hi){
    Queue&lt;Key&gt; queue = new Queue&lt;Key&gt;();
    keys(root， queue， lo， hi);
    return queue;
}
private void keys(Node x， Queue&lt;Key&gt; queue， Key lo， Key hi){
    if (x == null) return;
    int cmplo = lo.compareTo(x.key);
    int cmphi = hi.compareTo(x.key);
    if (cmplo &lt; 0) keys(x.left， queue， lo， hi);
    if (cmplo &lt;= 0 &amp;&amp; cmphi &gt;= 0) queue.enqueue(x.key);
    if (cmphi &gt; 0) keys(x.right， queue， lo， hi);
}
</code></pre>
</li>
<li>
<p>在一棵二叉查找树中，所有操作在<strong>最坏情况</strong>下所需的时间都和树的<strong>高度</strong>成正比。因此在某些场景下二叉查找树是不可接受的。</p>
</li>
</ul>
<h3 id="33-平衡查找树">3.3 平衡查找树</h3>
<ul>
<li>
<p><strong>2-3查找树</strong>:一棵2-3查找树或为一棵空树，或由以下结点组成：1️⃣  <strong>2-结点</strong>:含有一个键和两条链接，左链接指向的2-3树中的键都小于该结点，右链接指向的2-3树中的键都大于该结点。3️⃣  <strong>3-结点</strong>:含有两个键和三条链接，左链接指向的2-3树中的键都小于该结点，中链接指向的2-3树中的键都位于该结点的两个键之间，右链接指向的2-3树中的键都大于该结点。</p>
</li>
<li>
<p>一棵<strong>完美平衡</strong>的2-3查找树中的所有空链接到根结点的距离都应该是相同的。</p>
</li>
<li>
<p><strong>2-3树的查找</strong>：先将键和根结点中的键比较，如果它和其中任意一个相等，查找命中，否则根据比较的结果找到指向相应区间的链接，并在其指向的子树中<strong>递归</strong>地继续查找，如果是空链接则查找未命中.</p>
</li>
<li>
<p><strong>2-3树的插入</strong>：2-3树应该在插入后继续<strong>保持平衡</strong>.我们先进行一次未命中的查找，1️⃣ 如果结束于<strong>2-结点</strong>，就将要插入的键保存在其中，把这个2结点替换为一个3结点；2️⃣ 如果结束于<strong>根3-结点</strong>，就临时将新键存入该结点，使之成为<strong>4-结点</strong>，再把中键变为根结点，最小键变为它的左子树，最大键变为它的右子树，<strong>树高加一</strong>；3️⃣ 如果结束于<strong>父结点为2-结点的3-结点</strong>，先使其成为<strong>4-结点</strong>，再把中键移动到父结点中，最小键变为它的左子树，最大键变为它的右子树；4️⃣ 如果结束于<strong>父结点为3-结点的3-结点</strong>，先使其成为<strong>4-结点</strong>，再把中间键插入到它的父结点中，此时父结点也为一个4-结点，在这个结点上进行相同的变换，一直向上直到遇到2-结点或根结点。</p>
</li>
<li>
<p>在一颗2-3树中分解一个4-结点的情况汇总：<img src="https://images2018.cnblogs.com/blog/1340182/201804/1340182-20180426194923969-1770979554.png" alt="img" loading="lazy"></p>
</li>
<li>
<p>2-3树是<strong>由下向上</strong>生长的，因为插入后始终保持平衡，所以即使在<strong>最坏情况</strong>下<strong>插入</strong>和<strong>查找</strong>的时间复杂度也为<strong>O(lgN)</strong>。2-3树的缺点是具有两种类型的结点，因此需要大量代码实现和维护，额外开销很大</p>
</li>
<li>
<p>**红黑二叉查找树(红黑树)**是用来实现2-3树的一种简单的数据结构。它的基本思想是用标准的二叉查找树和一些额外的信息来表示2-3树。树中的链接被分为两种类型：<strong>黑链接</strong>是普通链接，<strong>红链接</strong>将两个2-结点连接起来构成一个3结点。</p>
</li>
<li>
<p>将红链接画平时，一颗红黑树就是一颗2-3树。</p>
</li>
<li>
<p>红黑树的另一种定义是含有红黑链接并满足下列条件的二叉查找树，满足这样定义的红黑树和相应的2-3树是一一对应的：1️⃣ 红链接均为<strong>左链接</strong>；2️⃣ 没有任何一个结点<strong>同时</strong>和<strong>两条红链接</strong>相连；3️⃣ 该树是<strong>完美黑色平衡</strong>的，即任意空链接到根结点的路径上的黑链接数量相同。</p>
</li>
<li>
<p>红黑树既是<strong>二叉查找树</strong>，也是<strong>2-3树</strong>(将由红链接相连的结点合并)，所以能够同时实现二叉查找树中简洁高效的查找方法和2-3树中高效的平衡插入算法。</p>
</li>
<li>
<p><strong>旋转</strong>：如果出现了<strong>红色右链接</strong>或<strong>两条连续的红链接</strong>，就需要旋。.<strong>左旋转</strong>右链接也就是将两个键中较大者的左结点变为较小者的右结点，并将较大者作为根结点，较小者作为它的左结点。<strong>右旋转</strong>只需将左旋转中的左右对调即可。</p>
<figure data-type="image" tabindex="1"><img src="C:%5CUsers%5CAngusCai%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200207195929455.png" alt="image-20200207195929455" loading="lazy"></figure>
<pre><code class="language-java">/*左旋转h的右链接*/
Node rotateLeft(Node h){
    Node x = h.right;
    h.right = x.left;
    x.left = h;
    x.color = h.color;
    h.color = RED;
    x.N = h.N;
    h.N = 1 + size(h.left) + size(h.right);
    return x;
}
</code></pre>
<pre><code class="language-java">/*右旋转h的左链接*/
Node rotateRight(Node h){
    Node x = h.left;
    h.left = x.right;
    x.right = h;
    x.color = h.color;
    x.N = h.N;
    h.N = 1 + size(h.left) + size(h.right);
    return x;
}
</code></pre>
</li>
<li>
<p>插入新键的几种情况：</p>
<p>1️⃣ <strong>向单个2-结点或树底部的2-结点插入新键</strong>：如果新键小于老键，新增一个红链接的结点即可。如果新键大于老键，新增的结点会产生一条红色的右链接，将其左旋转。</p>
<p>2️⃣ <strong>向3-结点插入大于两个键的新键</strong>：新键被连接到3-结点的右链接，直接将3-结点的两条链接都由红变黑，就得到了一棵由3个结点组成的平衡树。</p>
<p>3️⃣ <strong>向3-结点插入小于两个键的新键</strong>：新键被连接到最左边的空链接，即产生了两条连续的红链接，只需将上层的红链接右旋转即可变为情况2。</p>
<p>4️⃣ <strong>向3-结点插入介于两个键之间的新键</strong>：此时产生一左一右两条连续的红链接，只需将下层的红链接左旋转即可变为情况3。</p>
</li>
<li>
<p><strong>颜色转换</strong>：用于将子结点的颜色由红变黑，父结点的颜色由黑变红。</p>
<pre><code class="language-java">void flipColors(Node h){
    h.color =RED;
    h.left.color = BLACK;
    h.right.color = BLACK;
}
</code></pre>
</li>
<li>
<p>每次插入后都要将根结点设为黑色， 当根结点由红变黑时树的黑链接高度加1。</p>
</li>
<li>
<p><strong>插入</strong>:</p>
</li>
</ul>
<ol>
<li>
<p>如果右子结点是红色的而左子结点是黑色的，进行左旋转</p>
</li>
<li>
<p>如果左子结点是红色的且它的左子结点也是红色的，进行右旋转</p>
</li>
<li>
<p>如果左右子结点均为红色，进行颜色转换</p>
</li>
<li>
<p>不断地将红链接由中间键传递给父结点，直至遇到一个2-结点或根结点时，插入就完成了</p>
<pre><code class="language-java">public class RedBlackBST&lt;Key extends Comparable&lt;Key&gt;， Value&gt;{
    private Node root;
    public void put(Key key， Value val){
        root = put(root， key， val);
        root.color = BLACK;
    }
    private Node put(Node h， Key key， Value val){
        if (h==null){return new Node(key， val， 1， RED);}
        int cmp = key.compareTo(h.key);
        if (cmp &lt; 0) h.left = put(h.left， key， val);
        else if (cmp &gt; 0) h.right = put(h.right， key， val);
        else h.val = val;
        if (isRed(h.right) &amp;&amp; ! isRed(h.left)) h = rotateLeft(h);
        if (isRed(h.left) &amp;&amp; isRed(h.left.left)) h = rotateRight(h);
        if (isRed(h.left) &amp;&amp; isRed(h.right)) flipColors(h);
        h.N = size(h.left) + size(h.right) + 1;
        retrun h;
    }
}
</code></pre>
</li>
</ol>
<ul>
<li>红黑树<strong>查找</strong>，<strong>插入</strong>，<strong>删除</strong>和<strong>范围查询</strong>的时间复杂度在<strong>最坏情况</strong>下都为<strong>O(lgN)</strong></li>
</ul>
<p><strong><img src="https://images2018.cnblogs.com/blog/1340182/201804/1340182-20180426211529934-1774204337.png" alt="img" loading="lazy"></strong></p>
<h3 id="34散列表">3.4散列表</h3>
<ul>
<li>
<p>使用散列表的查找算法分为两步。第一步是用<strong>散列函数</strong>将被查找的键转化为数组的一个索引，第二步是处理<strong>碰撞冲突</strong>(多个键散列到相同索引值的情况)。</p>
</li>
<li>
<p>常用散列方法：1️⃣ <strong>正整数</strong>：散列最常用的方法是<strong>除留余数法</strong>。选择大小为<strong>素数</strong>M的数组，对于任意正整数k，计算k除以M的余数；2️⃣ <strong>浮点数</strong>：表示为<strong>二进制数</strong>然后再使用<strong>除留余数法</strong>；3️⃣ <strong>字符串</strong>：将每位字符表示为一个整数，然后一个比任何字符的值都大的数R来将字符串转化为一个R进制值，再在每一步用除留余数法；    4️⃣ <strong>组合键</strong>:类似于字符串，将组合值用R进制表示并在每一步用除留余数法。</p>
</li>
<li>
<p>Java 令所有数据类型都继承了一个能够返回一个32比特整数的<strong>hashCode( )<strong>方法。如果两个对象的</strong>hashCode( )<strong>方法返回值不同，那么这两个对象是不同的。但如果两个对象的</strong>hashCode( )</strong> 方法返回值相同，这两个对象也可能不同，还需要用**equals( )**方法判断。</p>
</li>
<li>
<p><strong>拉链法</strong>：将大小为M的数组中的每个元素指向一条<strong>链表</strong>，链表中的每个结点都存储了散列值为该元素的索引的键值对。基本思想是选择足够大的M，使得所有链表都<strong>尽可能短</strong>。<strong>查找</strong>分两步：1️⃣ 根据散列值找到对应的链表；2️⃣ 沿着链表顺序查找相应的键。</p>
<pre><code class="language-java">public class SeparateChainingHashST&lt;Key， Value&gt;{
    private int N;	//键值对总数
    private int M;	//散列表大小
    private SequentialSearchST&lt;Key， Value&gt;[] st;	//存放链表对象的数组；
    public SeparateChainingHashST(){
        this(997);
    }
    public SeparateChainingHashST(int M){
        this.M = M;	//创建M条链表；
        st = (SequentialSearchST&lt;Key，Value&gt;[]) new SequentialSearchST[M];
        for (int i = 0; i &lt; M; i++)
            st[i] = new SequentialSearchST();
    }
    private int hash(Key key){
        return (key.hashCode() &amp; 0x7fffffff) % M;)//屏蔽符号位，32位整数变为32位非负整数
    }
    public Value get(Key key){
        return (Value) st[hash(key)].get(key);
    }
    public void put(Key key， Value val){
        st[hash(key)].put(key， val);
    }
}
</code></pre>
</li>
<li>
<p>在一张含有M条链表和N个键的散列表中，<strong>未命中查找</strong>和<strong>插入</strong>的时间复杂度是<strong>O(N/M)</strong>。</p>
</li>
<li>
<p>散列后键的<strong>顺序信息丢失</strong>了。所以散列表不适合用来寻找最值或范围查找。</p>
</li>
<li>
<p>依靠数组中的空位解决碰撞冲突的方法叫<strong>开放地址散列表</strong>。其中最简单的是<strong>线性探测法</strong>：当碰撞发生时，检查散列表中的下一个位置，直到命中或遇到空元素为止。</p>
<pre><code class="language-java">public class LinearProbingHashST&lt;Key， Value&gt;{
    private int N;	//符号表中键值对的总数
    private int M = 16;	//线性探测表的大小；
    private Key[] keys;	//键
    private Value[] vals;	//值
    public LinearProbingHashST(){
        keys = (Key[]) new Object[M];
        vals = (Value[]) new Object[M];
    }
    private int hash(Key key){
        return (key.hashCode() &amp; 0x7fffffff) % M;	//	去除符号位
    }
    public void put(key key， Value val){
        if (N &gt;= M/2) resize(2*M);
        int i;
        for (i = hash(key); keys[i] != null; i = (i+1)%M)
            if (keys[i].equals(keys=)) {vals[i] = val; return;}	//存在就更新
        keys[i] = key;
        vals[i] = val;	//不存在就插入
        N++;
    }
    public Value get(Key key){
        for (int i = hash(key); keys[i] != null; i=(i+1) % M){
            if (keys[i].equals(key))
                return vals[i];
        return null;
        }
    }
}
</code></pre>
</li>
<li>
<p>当散列表快满时查找所需的探测次数是巨大的，但当使用率 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span> 小于 1/2 时探测的预计次数只在1.5到2.5之间。</p>
</li>
<li>
<p>开放地址散列表的<strong>删除</strong>除了将该键所在位置置为<strong>null</strong>，还需要将被删除键右侧的<strong>所有键重新插入</strong>散列表，以防之后的元素无法被查找。</p>
<pre><code class="language-java">public void delete(Key key){
    if (!contains(key)) return;
    int i = hash(key);
    while (!key.equals(keys[i]))
        i = (i+1) % M;
    keys[i] = null;
    vals[i] = null;
    i = (i+1) % M;
    while (keys[i] != null){
        Key keyToRedo = keys[i];
        Value valToRedo = vals[i];
        keys[i] = null;
        vals[i] = null;
        N--;
        put(keyToRedo， valToRedo);
        i = (i+1) % M;
    }
    N--;
    if (N &gt; 0 &amp;&amp; N == M/8) resize(M/2);
}
</code></pre>
</li>
<li>
<p>元素在数组中聚集成的一组连续的条目叫<strong>键簇</strong>，为了保证性能，应该使键簇尽可能<strong>短小</strong>。可以证明数组的<strong>使用率</strong>应该在1/8~1/2之间，所以在每次插入元素前和删除元素后都需动态调整大小。</p>
</li>
<li>
<p>问：为什么不将 <strong>hash(x)</strong> 实现为 <strong>x.hashCode( ) % M</strong> ?</p>
<p>答：散列值必须在0到M-1之间，而在Java中，取余(%)的结果可能是负数；如果用 **Math.abs( )**对于最大的整数会返回一个负值。</p>
</li>
</ul>
<h3 id="35-应用">3.5  应用</h3>
<ul>
<li>
<p>各种符号表实现的渐进性能的总结</p>
<figure data-type="image" tabindex="2"><img src="https://images2018.cnblogs.com/blog/1340182/201805/1340182-20180531202350579-759796183.png" alt="img" loading="lazy"></figure>
</li>
<li>
<p>相对于二叉查找树，散列表的优点是代码更简单，且查找时间最优。二叉查找树相对于散列表的优点在于抽象结构更简单，红黑树可以保证最坏情况下的性能且支持的操作更多（如排名、选择、排序和范围查找）。</p>
</li>
<li>
<p>使用put操作构造一张符号表以备get查询，这种应用叫做<strong>字典</strong></p>
</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://images2018.cnblogs.com/blog/1340182/201805/1340182-20180531204716938-1852543777.png" alt="img" loading="lazy"></figure>
<ul>
<li>一个键和多个值相关联的符号表叫做<strong>索引</strong>。用值来查找键的操作叫做<strong>反向索引</strong>.</li>
</ul>
<p><strong><img src="https://images2018.cnblogs.com/blog/1340182/201805/1340182-20180531205514270-1412021383.png" alt="img" loading="lazy"></strong></p>
<figure data-type="image" tabindex="4"><img src="https://images2018.cnblogs.com/blog/1340182/201805/1340182-20180531205751710-1966417605.png" alt="img" loading="lazy"></figure>
<ul>
<li>使用散列表表示<strong>稀疏矩阵</strong>可以大大提高矩阵与向量相乘的效率。它所需的时间和N+非零元素成正比，而用数组表示的话则为$N^2 $ ，N为矩阵的尺寸。</li>
</ul>
<figure data-type="image" tabindex="5"><img src="https://images2018.cnblogs.com/blog/1340182/201805/1340182-20180531210624806-249188382.png" alt="img" loading="lazy"></figure>
<h2 id="chapter-4-图">chapter 4 图</h2>
<h3 id="41-无向图">4.1 无向图</h3>
<ul>
<li><strong>图</strong>是由一组顶点和一组能够将两个顶点相连的边组成的，一般用0至V-1表示一张含有V个顶点的图中的各个<strong>顶点</strong>，用v-w或w-v表示连接v和w的<strong>边</strong>。边仅仅是两个顶点之间的连接的图称为<strong>无向图</strong>。</li>
<li>一条连接一个顶点和其自身的边称为<strong>自环</strong>。连接同一对顶点的两条边称为<strong>平行边</strong>。一般将含有平行边的图称为<strong>多重图</strong>，将没有平行边或自环的图称为<strong>简单图</strong>。</li>
<li>某个顶点的<strong>度数</strong>即为依附于它的边的总数。<strong>子图</strong>是由一幅图的所有边的一个子集组成的图。</li>
<li><strong>路径</strong>是由边顺序连接的一系列顶点。<strong>简单路径</strong>是一条没有重复顶点的路径。</li>
<li><strong>环</strong>是一条至少含有一条边且起点和终点相同的路径。<strong>简单环</strong>是一条不含有重复顶点和边的环。</li>
<li>如果从任意一个顶点都存在一条路径到达另一个任意顶点，那么这幅图是<strong>连通图</strong>。</li>
<li>图的<strong>密度</strong>是指已经连接的顶点对斩所有可能被连接的顶点对的比例，由此分出<strong>稀疏图</strong>和<strong>稠密图</strong>。</li>
<li><strong>二分图</strong>是一种能够将所有结点分为两部分的图，其中图的每条边所连接的两个顶点都分别属于不同的部分。</li>
<li>一般采用<strong>邻接表数组</strong>来表示图。它将每个顶点的所有相邻顶点都保存在该顶点对应的元素所指向的一张链表中。它使用的<strong>空间</strong>和<strong>V+E</strong>成正比。<strong>添加</strong>一条边所需的时间为<strong>常数</strong>。<strong>遍历</strong>顶点v的所有相邻顶点所需的时间和v的<strong>度数</strong>成正比。</li>
<li><strong>深度优先搜索(DFS)<strong>是搜索连通图的经典递归算法，所需的时间和顶点的</strong>度数之和</strong>成正比。使用的是<strong>栈</strong>:</li>
</ul>
<ol>
<li>在访问其中一个顶点时将它标记为已访问</li>
<li><strong>递归</strong>地访问该顶点的所有没有被标记过的邻居顶点</li>
</ol>
<ul>
<li><strong>广度优先搜索(BFS</strong>)是解决单点最短路径的经典算法，它所需的时间在最坏情况下和<strong>V+E</strong>成正比。使用的是<strong>队列</strong>，先将起点加入队列，重复以下步骤直到队列为空:</li>
</ul>
<ol>
<li>将与v相邻的所有未被标记过的顶点加入队列，删除v</li>
<li>取队列中的下一个顶点v并标记它</li>
</ol>
<ul>
<li>DFS和BFS的<strong>区别</strong>在于<strong>DFS</strong>总是获取<strong>最晚</strong>加入的顶点，而<strong>BFS</strong>总是获取<strong>最早</strong>加入的结点。</li>
<li><strong>DFS</strong>更适合实现图的抽象数据类型，因为它能更有效地利用已有的数据结构。而<strong>union-find</strong>算法适合于只需要判断连通性的任务。</li>
<li>利用一个符号表保存字符和索引，一个数组保存反向索引和一张图就可以实现<strong>符号图</strong>。</li>
</ul>
<h3 id="42-有向图">4.2 有向图</h3>
<ul>
<li>一幅<strong>有向图</strong>是由一组顶点和一组<strong>有方向</strong>的边组成的，每条有方向的边都连接着有序的一对顶点。在有向图中，一个顶点的<strong>出度</strong>为由该顶点指出的边的总数;一个顶点的<strong>入度</strong>为指向该顶点的边的总数。用v→w表示有向图中一条由v指向w的边。</li>
<li><strong>有向路径</strong>由一系列顶点组成，对于其中的每个顶点都存在一条有向边从它指向序列中的下一个顶点。<strong>有向环</strong>为一条至少含有一条边且起点和终点相同的有向路径。<strong>简单有向环</strong>是一条不含有重复的顶点和边的环。</li>
<li>和无向图类似，一般使用<strong>邻接表</strong>来表示有向图，用顶点v所对应的邻接链表中包含一个w顶点来表示边v→w。每条边都只会在其中出现一次。DFS和BFS同样可用于有向图。</li>
<li><strong>拓扑排序</strong>:给定一幅有向图，将所有的顶点排序，使得所有的有向边均从排在前面的元素指向排在后面的元素。即有<strong>优先级限制</strong>下的调度问题。当且仅当一幅有向图是无环图时它才能进行拓扑排序。</li>
<li><strong>有向无环图(DAG)<strong>是一幅不含有环的有向图。想要进行</strong>有向环检测</strong>，可以基于DFS，一旦找到一条边v→w且w已经存在于栈中，就找到了一个环。</li>
<li>DFS遍历一幅图以后，有以下三种排列顺序:</li>
</ul>
<ol>
<li><strong>前序</strong>:在递归调用之前将顶点加入队列，即dfs()的调用顺序</li>
<li><strong>后序</strong>:在递归调用之后将顶点加入队列，即顶点遍历完成的顺序</li>
<li><strong>逆后序</strong>:在递归调用之后将顶点压入栈，即这幅图的拓扑排序(如果是有向无环图)</li>
</ol>
<ul>
<li>如果两个顶点v和w是互相可达的，则称它们为<strong>强连通</strong>的。如果一幅有向图中的任意两个顶点都是强连通的，则称这幅有向图也是强连通的。两个顶点是强连通的当且仅当它们都在一个普通的有向环中。</li>
<li>通常用<strong>Kosaraju</strong>算法来计算强连通分量:</li>
</ul>
<ol>
<li>在给定的一幅有向图G中，计算它的反向图的逆后序排列</li>
<li>在G中进行DFS，但是要按照1得到的顺序来访问所有未被标记的顶点</li>
<li>所有在同一个递归DFS调用中被访问到的顶点都在同一个强连通分量中</li>
</ol>
<h3 id="43-最小生成树">4.3 最小生成树</h3>
<ul>
<li><strong>加权图</strong>是一种为每条边关联一个<strong>权值</strong>或是<strong>成本</strong>的图模型。</li>
<li>图的<strong>生成树</strong>是它的一棵含有其所有顶点的<strong>无环连通子图</strong>。一幅<strong>加权无向图</strong>的**最小生成树(MST)**是它的一棵权值最小的生成树。</li>
<li>在计算最小生成树时，做以下约定:</li>
</ul>
<ol>
<li>只考虑连通图</li>
<li>边的权重不一定表示距离</li>
<li>边的权重可能是0或者负数</li>
<li>所有边的权重都各不相同</li>
</ol>
<ul>
<li><strong>树</strong>的两个重要性质:</li>
</ul>
<ol>
<li>用一条边连接树中的任意两个顶点都会产生一个新的环</li>
<li>从树中删去一条边将会得到两颗独立的树</li>
</ol>
<ul>
<li>图的一种<strong>切分</strong>是将图的所有顶点分为两个非空且不重复的两个集合。<strong>横切边</strong>是一条连接两个属于不同集合的顶点的边。</li>
<li><strong>切分定理</strong>:在一幅加权图中，给定任意的切分，它的横切边中的权重最小者必然属于图的最小生成树。</li>
<li>切分定理是解决最小生成树问题的所有算法的基础。这些算法都是一种<strong>贪心算法</strong>的特殊情况。即找到一种切分，它产生的横切边均不为黑色，将它权重最小的横切边标记为黑色，直到标记了V-1条黑色边为止。不同之处在于<strong>保存切分</strong>和<strong>判定权重最小</strong>的横切边的方式。</li>
<li>同样可以使用<strong>邻接表</strong>来表示加权无向图，只需要增加一个<strong>权重域</strong>。</li>
<li><strong>Prim算法</strong>:</li>
</ul>
<ol>
<li>一开始最小生成树只有一个顶点，然后会向它添加V-1条边。每次总是将下一条<strong>连接</strong>树顶点与非树顶点且<strong>权重最小</strong>的边加入树中。每一步总是为一棵树<strong>添加一条边</strong>。</li>
<li>使用<strong>优先队列</strong>来根据权重比较所有边</li>
<li>分为<strong>延时实现</strong>和<strong>即时实现</strong>。区别在于是否<strong>立即删除</strong>失效的横切边(即连接新加入的顶点和树中已有顶点之间的边)。</li>
<li><strong>延时实现</strong>所需<strong>空间</strong>与<strong>E</strong>成正比，所需<strong>时间</strong>与<strong>ElogE</strong>成正比。</li>
<li><strong>即时实现</strong>不仅删除失效的边，而是仅保存非树顶点到树顶点的边中权重最小的那条，并在每次加入新顶点后检查是否需要更新。所需<strong>空间</strong>与<strong>V</strong>成正比，<strong>时间</strong>与<strong>ElogV</strong>成正比。</li>
</ol>
<ul>
<li><strong>Kruskal算法</strong>:</li>
</ul>
<ol>
<li>按照边的<strong>权重顺序</strong>处理它们，将边加入最小生成树中，加入的边不会与已经加入的边构成环，直到树中含有V-1条边为止。每一步总是连<strong>接森林中的两棵树</strong>(包括单顶点树)。</li>
<li>在实现中，使用<strong>优先队列</strong>来将边按照权重排序，使用<strong>union-find</strong>来识别会形成环的边，以及一条<strong>队列</strong>来保存最小生成树的所有边。</li>
<li>所需<strong>空间</strong>与<strong>E</strong>成正比，所需<strong>时间</strong>与<strong>ElogE</strong>成正比。</li>
</ol>
<h3 id="44-最短路径">4.4 最短路径</h3>
<ul>
<li>在一幅<strong>加权有向图</strong>中，从顶点s到顶点t的<strong>最短路径</strong>是所有从s到t的路径中的<strong>权重最小</strong>者。</li>
<li>**最短路径树(SPT)**包含了顶点s到所有可达的顶点的最短路径</li>
<li><strong>边v-&gt;w的松弛</strong>是指检查从顶点s到w的最短路径是否是先从s到v，然后再由v到w，即。如果是，则更新，如果不是，则称这条边<strong>失效</strong>了。</li>
<li><strong>顶点的松弛</strong>是指对该顶点指出的所有边进行松弛。</li>
<li><strong>最优性条件</strong>:当且仅当对于从v到w的任意一条边e，这些值都满足distTo[w]&lt;=distTo[v]+e。weight()时它们是最短路径的长度。这证明了判断是否为最短路径的<strong>全局条件</strong>与松弛时检测的<strong>局部条件</strong>是<strong>等价</strong>的。</li>
<li><strong>通用最短路径算法</strong>:放松图中的任意边，直到不存在有效边为止。</li>
<li><strong>Dijkstra算法</strong>(注意只能解决<strong>正权重</strong>的加权有向图中的最短路径问题):</li>
</ul>
<ol>
<li>首先将distTo[s]初始化为0，distTo[]中的其他元素初始化为起点s到该顶点的距离，注意如果不相邻则为正无穷。</li>
<li>然后将distTo[]<strong>最小的非树顶点松弛</strong>并加入树中</li>
<li>重复2，直到所有的顶点都在树中或者所有的非树顶点的distTo[]值均为无穷大。</li>
</ol>
<ul>
<li>
<p>按照<strong>拓扑顺序</strong>放松顶点，就能在和E+V成正比的时间内解决<strong>无环加权有向图</strong>的单点最短路径问题。同理，要解决无环加权有向图的<strong>最长路径</strong>问题，只需将原图中所有边的权重变为负值，再求最短路径即可。</p>
</li>
<li>
<p>当且仅当<strong>加权有向图</strong>中至少存在一条从s到v的有向路径且该路径上的任意顶点都不存在于任何<strong>负权重环</strong>中时，s到v的最短路径才是存在的。</p>
</li>
<li>
<p>数据结构--Dijkstra算法最清楚的讲解 https://blog.csdn.net/heroacool/article/details/51014824</p>
</li>
<li>
<p>它的主要特点是以起始点为中心向外层层扩展(广度优先搜索思想)，直到扩展到终点为止</p>
</li>
</ul>
<p><strong>基本思想</strong></p>
<ul>
<li>
<p>通过Dijkstra计算图G中的最短路径时，需要指定起点s(即从顶点s开始计算)。此外，引进两个集合S和U。S的作用是记录已求出最短路径的顶点(以及相应的最短路径长度)，而U则是记录还未求出最短路径的顶点(以及该顶点到起点s的距离)。</p>
</li>
<li>
<p>初始时，S中只有起点s；U中是除s之外的顶点，并且U中顶点的路径是”起点s到该顶点的路径”。然后，从U中找出路径最短的顶点，并将其加入到S中；接着，更新U中的顶点和顶点对应的路径。 然后，再从U中找出路径最短的顶点，并将其加入到S中；接着，更新U中的顶点和顶点对应的路径。 … 重复该操作，直到遍历完所有顶点。</p>
</li>
</ul>
<p><strong>操作步骤</strong>：1️⃣ 初始时，S只包含起点s；U包含除s外的其他顶点，且U中顶点的距离为”起点s到该顶点的距离”[例如，U中顶点v的距离为(s,v)的长度，然后s和v不相邻，则v的距离为∞]。2️⃣ 从U中选出”距离最短的顶点k”，并将顶点k加入到S中；同时，从U中移除顶点k。3️⃣ 更新U中各个顶点到起点s的距离。之所以更新U中顶点的距离，是由于上一步中确定了k是求出最短路径的顶点，从而可以利用k来更新其它顶点的距离；例如，(s,v)的距离可能大于(s,k)+(k,v)的距离。4️⃣ 重复步骤(2)和(3)，直到遍历完所有顶点。</p>
<pre><code class="language-python">#dijkstra算法实现，有向图和路由的源点作为函数的输入，最短路径最为输出
def dijkstra(graph,src):
    # 判断图是否为空，如果为空直接退出
    if graph is None:
        return None
    nodes = [i for i in range(len(graph))]  # 获取图中所有节点
    visited=[]  # 表示已经路由到最短路径的节点集合
    if src in nodes:
        visited.append(src)
        nodes.remove(src)
    else:
        return None
    distance={src:0}  # 记录源节点到各个节点的距离
    for i in nodes:
        distance[i]=graph[src][i]  # 初始化
    # print(distance)
    path={src:{src:[]}}  # 记录源节点到每个节点的路径
    k=pre=src
    while nodes:
        mid_distance=float('inf')
        for v in visited:
            for d in nodes:
                new_distance = graph[src][v]+graph[v][d]
                if new_distance &lt; mid_distance:
                    mid_distance=new_distance
                    graph[src][d]=new_distance  # 进行距离更新
                    k=d
                    pre=v
        distance[k]=mid_distance  # 最短路径
        path[src][k]=[i for i in path[src][pre]]
        path[src][k].append(k)
        # 更新两个节点集合
        visited.append(k)
        nodes.remove(k)
        print(visited,nodes)  # 输出节点的添加过程
    return distance,path
if __name__ == '__main__':
    graph_list = [ [0, 2, 1, 4, 5, 1],
            [1, 0, 4, 2, 3, 4],
            [2, 1, 0, 1, 2, 4],
            [3, 5, 2, 0, 3, 3],
            [2, 4, 3, 4, 0, 1],
            [3, 4, 7, 3, 1, 0]]

    distance,path= dijkstra(graph_list, 0)  # 查找从源点0开始带其他节点的最短路径
    print(distance,path)
</code></pre>
<ul>
<li><strong>Bellman-Ford算法</strong>:</li>
</ul>
<ol>
<li>在任意含有V个顶点的<strong>加权有向图</strong>中给定起点s，从s无法到达任何负权重环，可以解决其中的单点最短路径问题</li>
<li>将distTo[s]初始化为0，其他distTo[]元素初始化为无穷大，以任意顺序放松有向图的所有边，重复V-1轮</li>
<li>算法所需的<strong>时间</strong>和<strong>EV</strong>成正比，<strong>空间</strong>和<strong>V</strong>成正比。</li>
</ol>
<ul>
<li><strong>套汇问题</strong>等价于加权有向图中的负权重环的检测问题。</li>
</ul>
<figure data-type="image" tabindex="6"><img src="https://images2018.cnblogs.com/blog/1340182/201806/1340182-20180617174306628-1036182212.png" alt="img" loading="lazy"></figure>
<h2 id="chapter-5-字符串">chapter 5 字符串</h2>
<h3 id="51-字符串排序">5.1 字符串排序</h3>
<ul>
<li>
<p>在Java中，String类型的**length( )**方法实现了获取字符串的长度的操作。**substring( )**方法实现了提取特定的子字符串的操作。</p>
</li>
<li>
<p>字符串排序方法可以分为从右到左检查键中的字符的<strong>低位优先(LSD)<strong>和从左到右检查键中字符的</strong>高位优先(MSD)</strong>。</p>
</li>
<li>
<p><strong>键索引计数法</strong>是一种适用于<strong>小整数键</strong>的简单排序方法，它要求数组a[]中的每个元素都保存一个字符串和一个组号，原来元素是依据字符串排列的，现在希望按组号排列，在组内保持原顺序.键索引计数法排序N个键为0到R-1之间的整数的元素需要访问数组<strong>11N+4R+1</strong>次。</p>
</li>
<li>
<p>键索引计数法步骤：1️⃣ <strong>频率统计</strong>：使用一个数组count[]计算每个键出现的频率。如果键为r，就将count[r+1]加1。2️⃣ <strong>将频率转换为索引</strong>：任意给定的键的起始索引均为所有较小的键所对应的出现频率之和，只需循环count[r+1]+=count[r]这个语句即可转换出一张索引表。3️⃣ <strong>数据分类</strong>：有了索引表后，将所有元素移动到一个辅助数组aux[]中进行排序。每次移动后将count[]中对应元素的值加1，这保证了这种排序的<strong>稳定性</strong>。4️⃣ <strong>回写</strong>：将排序结果复制回原数组中。</p>
<pre><code class="language-java">int N = a.length;
String[] aux = new String[N];
int[] count = new int[R+1];
// 计算出现频率
for (int i = 0; i &lt; N; i++)
    count[a[i].key() + 1]++;
//将频率转换为索引
for (int r = 0; r &lt; R; r++)
    count[r+1] += count[r];
//将元素分类
for (int i = 0; i &lt; N; i++)
    aux[count[a[i].key()]++] = a[i];
//回写
for (int i = 0; i &lt; N; i++)
    a[i] = aux[i];
</code></pre>
</li>
<li>
<p><strong>低位优先的字符串排序(LSD)</strong>：将<strong>等长字符串(<strong>假设长度为W)排序可以通过从右向左以每个位置的字符作为键，用键索引计数法将字符串排序W次实现。这依赖于键索引计数法的稳定性。对于基于R个字符的字母表的N个以长为W的字符串为键的元素，LSD需要访问</strong>~7WN+3WR</strong>次数组。因为实际中R&lt;&lt;N，因此LSD算法的<strong>时间</strong>是<strong>O(WN)</strong>。</p>
<pre><code class="language-java">public class LSD{
    public static void sort(String[] a, int w){
        // 通过前W个字符将a[]排序
        int N = a.length;
        int R = 256;
        String[] aux = new String[N];
        for (int d = w-1; d &gt;= 0; d--){
            int[] count = new int[R+1]; //根据第d个字符用键索引计数法排序
            for (int i = 0; i &lt; N; i++)
                count[a[i].charAt(d) + 1]++; // 计算出现频率
            for (int r = 0; r &lt; R; r++)
                count[r+1] += count[r]; //将频率转换为索引
            for (int i = 0; i &lt; N; i++)
                aux[count[a[i].charAt(d)]++] = a[i]; //将元素分类
            for (int i = 0; i &lt; N; i++)
                a[i] = aux[i]; //回写
        }
    }
}
</code></pre>
</li>
<li>
<p><strong>高位优先的字符串排序(MSD)</strong>：首先用键索引计数法将所有字符串按照首字母排序，然后再<strong>递归地</strong>将每个首字母所对应的<strong>子数组排序</strong>(忽略首字母)。对于MSD来说，将小数组切换到<strong>插入排序</strong>对于高位优先的字符串排序算法是必须的，另外它无法很好的处理<strong>等值键</strong>。对于基于R个字符的字母表的N个平均长度为w的字符串，MSD需要访问8N+3R到7wN+3wR之间次数组。</p>
<pre><code class="language-java">public class MSD{
    private static int R = 256;
    private static final int M = 15;	//小数组的切换阈值
    private static String[] aux;
    private static int charAt(String s,int d){
        if (d &lt; s.lengtg())	return s.charAt(d);else return -1;
    }
    public static void sort(String[] a){
        int N = a.length;
        aux = new String[N];
        sort(a, 0, N-1, 0);
    }
    private static void sort(String[] a, int lo, int hi, int d){
        //以第d个字符为键将a[lo]至a[hi]排序
        if (hi &lt;= lo + M){
            Insertion.sort(a, lo, hi, d);
            return;
        }
        int[] count = new int[R+2];
        for (int i = lo; i &lt;= hi; i++)
            count[charAt(a[i], d) + 2]++;
        for (int r = 0; r &lt; R+1; r++)
            count[r+1] += count[r];
        for (int i = lo; i &lt;= hi; i++)
            aux[count[charAt(a[i], d) + 1]++] = a[i];
        for (int i = lo; i &lt;= hi; i++)
            a[i] = aux[i - lo];
        for (int r = 0; r &lt; R; r++)
            sort(a, lo+count[r], lo+count[r+1]-1, d+1);
    }
}
</code></pre>
</li>
<li>
<p><strong>三向字符串快速排序</strong>:根据键的首字母进行<strong>三向切分</strong>，仅在中间子数组的中的下一个字符继续递归排序.它能够很好地处理等值键，有较长公共前缀的键，取值范围较小的键和小数组.另外它不需要额外的空间.</p>
</li>
</ul>
<figure data-type="image" tabindex="7"><img src="https://images2018.cnblogs.com/blog/1340182/201806/1340182-20180619181810227-1440141342.png" alt="img" loading="lazy"></figure>
<h3 id="52-单词查找树">5.2 单词查找树</h3>
<ul>
<li><strong>单词查找树(trie树)<strong>的每个结点都有R条链接，R为字母表的大小。但是一般其中都含有大量的空链接，可以被忽略。每条</strong>链接</strong>都对应着一个<strong>字符</strong>，每个<strong>键</strong>所关联的<strong>值</strong>保存在该键的最后一个字母所对应的<strong>结点</strong>中。</li>
<li><strong>查找</strong>给定字符串键所对应的值的方式就是从根结点开始检查某条路径上的所有结点，这意味着到达树中表示尾字符的结点或者一个空链接。<strong>插入</strong>之前需要先进行一次查找，如果遇到了空链接则为键中还未被检查的每个字符创建一个对应结点，如果到达了尾字符结点则将该结点的值设为要插入的键所对应的值。</li>
<li>单词查找树的结点是一个<strong>值</strong>和大小为R的<strong>数组</strong>构成的。将基于含有R个字符的字母表的单词查找树称为R向单词查找树。</li>
<li>可以用递归的方法<strong>查找所有键</strong>，方法的参数是结点和该结点关联的字符串。如果一个结点的值非空，就将它相关联的字符串加入队列，然后递归访问它的链接数组所指向的所有可能的字符结点。</li>
<li>要<strong>删除</strong>一个键值对，先找到键所对应的结点并将它的值设为空，如果它有指向子结点的非空链接则删除结束，如果它的所有链接均为空就从数据结构中删去这个结点，再检查它的父结点的所有链接是否为空。</li>
<li>对于任意给定的一组键，单词查找树都是<strong>唯一</strong>的。<strong>查找</strong>需要访问数组的次数最多是键的长度加1。<strong>未命中查找</strong>平均所需检查的结点数量为(logR)N。树中的<strong>链接总数</strong>在RN到RNw之间。</li>
<li><strong>三向单词查找树</strong>:用来避免R向单词查找树过度的空间消耗.每个结点都含有一个字符，三条链接和一个值。三条链接对应着当前字母小于，等于和大于结点字母的所有键。所需的空间在3N到3Nw之间。查找未命中平均需要比较字符~lnN次。</li>
</ul>
<figure data-type="image" tabindex="8"><img src="https://images2018.cnblogs.com/blog/1340182/201807/1340182-20180706120148697-1361649056.png" alt="img" loading="lazy"></figure>
<h3 id="53-子字符串查找">5.3 子字符串查找</h3>
<ul>
<li>子字符串查找问题：给定一段长度为<strong>N</strong>的<strong>文本</strong>和一个长度为M的<strong>模式字符串</strong>，在文本中找到一个和该模式相符的子字符串。一般来说M相对于N是<strong>很小</strong>的。</li>
<li><strong>暴力子字符串查找算法</strong>就是遍历文本字符串，如果某字符和模式的第一个字符匹配则移动指向模式的指针，否则移动指向文本的指针。这种方法在最坏情况下需要**~NM**次字符比较(例如二进制文本)。</li>
<li><strong>KMP子字符串查找算法</strong>(注:书中用确定有限状态自动机DFA的思想来讲解，个人感觉不好理解，本文用了大一学数据结构时的解释方法):</li>
</ul>
<ol>
<li><strong>基本思想</strong>:当出现不匹配时，就能知晓一部分文本的内容，可以利用这些信息避免将指针回退到所有已知字符之前。</li>
<li><strong>预处理</strong>:根据模式计算出一个转移数组<strong>next[]</strong>.其中next[0]=-1，next[1]=0，next[j]表示模式字符串中第0位到第j-1位中相同的最长前缀和最长后缀的长度。next数组可以用模式匹配的思想编程得到。</li>
<li><strong>发生不匹配</strong>:目标串的指针不变，若next[j]&gt;=0，则将模式字符串右移j-next[j]位个字符，用模式的第next[j]个字符与文本的第i个字符比较.若next[j]=-1，则将模式字符串右移j+1个字符，用第0个字符与文本的第i+1个字符比较。</li>
<li><strong>优化</strong>:如果根据next数组回退之后的位置的字符和现有字符相同，则必定是不匹配，仍要继续回退，因此建立nextval数组，将重复字符的回退位置都设为第一个该字符的回退位置.</li>
<li>KMP算法适用于在重复性很高的文本中查找重复性很高的模式，它访问的字符不会超过<strong>M+N</strong>个.</li>
</ol>
<ul>
<li><strong>Boyer-Morre字符串查找算法</strong>:</li>
</ul>
<ol>
<li>使用数组right[]记录字母表中的每个字符在模式中出现的最靠右的地方，不存在则为-1.含义是如果该字符出现在文本中且在查找时造成了一次匹配失败，模式应该向右跳跃多远.</li>
<li>如果造成匹配失败的字符不包含在模式中，则将模式字符串向右移动j+1个位置</li>
<li>如果包含在模式字符串中，则将模式向右移动j-right['char']</li>
<li>如果这种方式无法增大i，就将i加1</li>
<li>一般情况下，Boyer-Moore需要**~N/M**次字符比较.</li>
</ol>
<ul>
<li><strong>Rabin-Karp指纹字符串查找算法</strong>:</li>
</ul>
<ol>
<li><strong>基本思想</strong>:这是一种基于散列的算法.长度为M的字符串对应着一个R进制的M位数，将该数除以一个随机的素数Q并取余就可以将它保存在大小为Q的散列表中.</li>
<li><strong>计算散列函数</strong>:在文本中将子字符串右移一位，对应的M位数操作就是将它减去第一个数字的值，乘上R，再加上最后一个数字的值.又因为在每次算数操作之后取余等价于在所有算数操作完成后取余，因此只需对上述操作的每一步先取余就可以得到下一位的子字符串的散列值.</li>
<li><strong>技巧</strong>:为了避免有多个子字符串有相同散列值，可以将Q设为一个大于10<sup>20的值，这样冲突的概率将小于10</sup>-20.</li>
</ol>
<figure data-type="image" tabindex="9"><img src="https://images2018.cnblogs.com/blog/1340182/201807/1340182-20180707185045295-1645437613.png" alt="img" loading="lazy"></figure>
<h3 id="54-正则表达式">5.4 正则表达式</h3>
<ul>
<li>正则表达式就是按照某种<strong>模式</strong>进行<strong>字符匹配</strong>的表达式。书中使用<strong>语言</strong>指代一个字符串的集合.模式的描述由<strong>连接</strong>，<strong>或(|)</strong>，**闭包(*)**三种基本操作构成。</li>
<li><strong>字符集描述集</strong>用于简化正则表达式</li>
</ul>
<figure data-type="image" tabindex="10"><img src="https://images2018.cnblogs.com/blog/1340182/201807/1340182-20180711013529329-180853342.png" alt="img" loading="lazy"></figure>
<ul>
<li><strong>闭包的简写</strong></li>
</ul>
<p><strong><img src="https://images2018.cnblogs.com/blog/1340182/201807/1340182-20180711013609776-1709356843.png" alt="img" loading="lazy"></strong></p>
<ul>
<li>.|*()是用来构造正则表达式的<strong>元字符</strong>，因此要用\开头的<strong>转义字符</strong>来表示</li>
<li>正则表达式模拟匹配程序的总体结构是:构造和给定正则表达式相对应的<strong>非确定有限状态自动机(NFA)</strong>，模拟NFA在给定文本上的运行轨迹.</li>
<li>NFA有以下特点:</li>
</ul>
<ol>
<li>长度为M的正则表达式中的每个字符在对应NFA中<strong>有且只有</strong>一个对应状态，NFA起始状态为0，并有一个<strong>虚拟的</strong>接受状态M</li>
<li>字母表中的字符所对应的状态都有一条<strong>指向模式中的下一个字符</strong>对应状态的<strong>黑边</strong>.</li>
<li>元字符所对应的状态至少有一条指出的<strong>红边</strong>，可能指向任意状态</li>
</ol>
<ul>
<li>NFA的<strong>状态转换</strong>:</li>
</ul>
<ol>
<li><strong>匹配转换</strong>:如果文本中的当前字符和当前字母表中的字符匹配，NFA可以扫过文本中的字符并由<strong>黑边</strong>转换到下一个状态</li>
<li><strong>ε转换</strong>:NFA可以通过<strong>红边</strong>转换到另一个状态而不扫描文本中的字符</li>
</ol>
<ul>
<li>使用长度为M+1的<strong>数组</strong>来保存正则表达式本身，这个数组也表示了<strong>匹配转换</strong>.使用<strong>有向图</strong>来表示<strong>ε转换</strong>.首先查找所有从状态0通过ε转换可达的状态来初始化<strong>可达性</strong>集合，然后如果有字符匹配了集合中的状态，就将集合改为这个字符通过匹配转换后到达的状态，再加上这些状态通过ε转换可达的状态.</li>
<li>判定一个长度为M的正则表达式所对应的NFA能否识别一段长度为N的文本所需的时间在最坏情况下和<strong>NM</strong>成正比.构造对应的NFA所需的时间和空间在最坏情况下与<strong>M</strong>成正比</li>
</ul>
<h3 id="55-数据压缩">5.5 数据压缩</h3>
<ul>
<li>现代计算机系统中的所有类型的数据都是用<strong>二进制</strong>表示的.用<strong>比特流</strong>表示比特的序列，用<strong>字节流</strong>表示可以看作固定大小的字节序列的比特序列.</li>
<li>数据压缩的基础模型由<strong>压缩盒</strong>(将比特流B转化为压缩版本C(B))和<strong>展开盒</strong>(将C(B)转化回B)组成，用|B|表示比特流中比特的数量，则C(B)/|B||称为<strong>压缩率</strong>.这种模型叫做<strong>无损压缩模型</strong>.常用于数值数据或可执行代码的压缩.</li>
<li>不存在能够压缩任意比特流的算法，因此无损压缩算法必须尽量利用被压缩的数据流中的<strong>已知结构</strong>(小规模字母表，较长的连续相同的位或字符，频繁使用的字符，较长的连续重复的位或字符).</li>
<li>**游程编码(RLE)**的基本原理是用长度代替具有相同值的连续符号，连续符号构成了一段连续&quot;游程&quot;.适用于含有较长游程的数据，比如高分辨率的位图.</li>
<li><strong>霍夫曼压缩</strong>的思想是用较少的比特表示出现较频繁的字符，它是一种<strong>前缀码</strong>(所有字符编码都不会成为其他字符编码的前缀).<strong>构造霍夫曼树</strong>的过程是:先找到频率最小的两个结点，然后创造一个以两者为子结点且频率为两者之和的新结点，不断重复这个过程知道所有结点被合并为一棵单词查找树.</li>
<li><strong>LZW压缩算法</strong>是为变长模式生成一张定长的符号表:</li>
</ul>
<ol>
<li>找出未处理的输入在符号表中最长的前缀字符串s</li>
<li>输出s的编码</li>
<li>继续扫描s之后的一个字符c</li>
<li>在符号表中将s+c的值设为下一个编码值</li>
</ol>

                        </div>
                        
                            <div class="post-toc">
                                <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#chapter-1-%E5%9F%BA%E7%A1%80">chapter 1 基础</a>
<ul>
<li><a href="#11-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B">1.1 基础编程模型</a></li>
<li><a href="#12-%E6%95%B0%E7%BB%84%E6%8A%BD%E8%B1%A1">1.2 数组抽象</a></li>
<li><a href="#13-%E8%83%8C%E5%8C%85-%E6%A0%88-%E9%98%9F%E5%88%97">1.3 背包、栈、队列</a></li>
<li><a href="#14-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90">1.4 算法分析</a></li>
<li><a href="#15-union-find%E7%AE%97%E6%B3%95">1.5 union-find算法</a></li>
</ul>
</li>
<li><a href="#chapter-2-%E6%8E%92%E5%BA%8F">chapter 2 排序</a>
<ul>
<li><a href="#21-%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95">2.1 初级排序算法</a></li>
<li><a href="#22-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F">2.2 归并排序</a></li>
<li><a href="#23-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">2.3 快速排序</a></li>
<li><a href="#24-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97">2.4 优先队列</a></li>
<li><a href="#25-%E5%BA%94%E7%94%A8">2.5 应用</a></li>
</ul>
</li>
<li><a href="#chapter-3-%E6%9F%A5%E6%89%BE">chapter 3 查找</a>
<ul>
<li><a href="#31-%E7%AC%A6%E5%8F%B7%E8%A1%A8">3.1 符号表</a></li>
<li><a href="#32-%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91">3.2 二叉查找树</a></li>
<li><a href="#33-%E5%B9%B3%E8%A1%A1%E6%9F%A5%E6%89%BE%E6%A0%91">3.3 平衡查找树</a></li>
<li><a href="#34%E6%95%A3%E5%88%97%E8%A1%A8">3.4散列表</a></li>
<li><a href="#35-%E5%BA%94%E7%94%A8">3.5  应用</a></li>
</ul>
</li>
<li><a href="#chapter-4-%E5%9B%BE">chapter 4 图</a>
<ul>
<li><a href="#41-%E6%97%A0%E5%90%91%E5%9B%BE">4.1 无向图</a></li>
<li><a href="#42-%E6%9C%89%E5%90%91%E5%9B%BE">4.2 有向图</a></li>
<li><a href="#43-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91">4.3 最小生成树</a></li>
<li><a href="#44-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84">4.4 最短路径</a></li>
</ul>
</li>
<li><a href="#chapter-5-%E5%AD%97%E7%AC%A6%E4%B8%B2">chapter 5 字符串</a>
<ul>
<li><a href="#51-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8F">5.1 字符串排序</a></li>
<li><a href="#52-%E5%8D%95%E8%AF%8D%E6%9F%A5%E6%89%BE%E6%A0%91">5.2 单词查找树</a></li>
<li><a href="#53-%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE">5.3 子字符串查找</a></li>
<li><a href="#54-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">5.4 正则表达式</a></li>
<li><a href="#55-%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9">5.5 数据压缩</a></li>
</ul>
</li>
</ul>
</li>
</ul>

                            </div>
                            
                                
                                    
                                            <!--zh-->
                                            <section class="post-copyright zh">
                                                <p class="copyright-item ">
                                                    <span>&#x4F5C;&#x8005;:</span>
                                                    <span>风中呓语</span>
                                                </p>

                                                <p class="copyright-item">
                                                    <span>&#x6C38;&#x4E45;&#x94FE;&#x63A5;:</span>
                                                    <span><a href="https://Angus1996.github.io/post/lesslesssuan-fa-4th-editiongreatergreater-xue-xi-bi-ji/">https://Angus1996.github.io/post/lesslesssuan-fa-4th-editiongreatergreater-xue-xi-bi-ji/</a></span>
                                                </p>

                                                <p class="copyright-item">
                                                    <span>&#x534F;&#x8BAE;:</span>
                                                    <span>MIT License</span>
                                                </p>
                                            </section>
                                            
                                                
                                                    
                                                                    <!--Share-->
                                                                    <span style="margin-right:15px">
                        <i class="post-share"></i>
                        <span>&#x5206;&#x4EAB;:</span>
                                                                    <a title="QR 码" target="_blank" href="https://api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://Angus1996.github.io/post/lesslesssuan-fa-4th-editiongreatergreater-xue-xi-bi-ji/"><i class="fa fa-qrcode"></i></a>
                                                                    <a title="QQ" target="_blank" href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://Angus1996.github.io/post/lesslesssuan-fa-4th-editiongreatergreater-xue-xi-bi-ji/&sharesource=qzone&title=《算法 4th edition》学习笔记&pics=https://Angus1996.github.io/images/avatar.png?v=1666016988061&summary="><i class="fa fa-qq"></i></a>
                                                                    <a title="新浪微博" target="_blank" href="https://service.weibo.com/share/share.php?url=https://Angus1996.github.io/post/lesslesssuan-fa-4th-editiongreatergreater-xue-xi-bi-ji/&sharesource=weibo&title=《算法 4th edition》学习笔记 + " - " + &pic="https://Angus1996.github.io/images/avatar.png?v=1666016988061 "><i class="fa fa-weibo "></i></a>

                                                                    </span>
                                                                    
                                                                        <div class="reward ">
                                                                            <div class="reward-button ">&yen;
                                                                                <span class="reward-code "> 
                        <span class="alipay-code "> <img class="alipay-img " alt = "support " src="https://i.loli.net/2021/10/30/EmwXkqjKQtf7Szv.jpg"><b>支付宝</b> </span>
                                                                                <span class="wechat-code "> <img alt ="support " class="wechat-img " src="https://i.loli.net/2021/10/30/2egQ6Z4xyUipdrK.jpg"><b>微信</b> </span> </span>
                                                                            </div>
                                                                        </div>
                                                                        
                                                                            <!--zh-->
                                                                            <section class="post-tags zh ">
                                                                                <div>
                                                                                    <span>&#x6807;&#x7B7E;:</span>
                                                                                    <span class="tag ">
                        
                        
                        <a href="https://Angus1996.github.io/tag/suan-fa/">#
                    算法
                        </a>
                        
                            
                                </span>
                                                                                </div>
                                                                                <div>
                                                                                    <a href="javascript:window.history.back();">
                        &#x8FD4;&#x56DE;</a>
                                                                                    <span>&dot;</span>
                                                                                    <a href="#">&#x4E3B;&#x9875;</a>
                                                                                </div>
                                                                            </section>

                                                                            
                                                                                <!---->
                                                                                <section class="post-nav">
                                                                                    
                                                                                        <a class="prev" rel="prev" href="https://Angus1996.github.io/post/yan-zheng-zhong-xin-ji-xian-ding-li-python-shi-xian/">
                                                                                            验证中心极限定理（python实现）
                                                                                        </a>
                                                                                        
                                                                                            
                                                                                                <a class="next" rel="next" href="https://Angus1996.github.io/post/ccf-bdci-2019-duo-ren-chong-ren-lian-shi-bie-bi-sai-zong-jie/">
                                                                                                    CCF BDCI 2019 多人种人脸识别比赛总结
                                                                                                </a>
                                                                                                
                                                                                </section>
                    </article>
                </div>
                
                    
                        <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container" style="width: 100%;max-width: 780px;margin: auto;"></div>

<script>
    var gitalk = new Gitalk({
        clientID: '55a2d4ff64d03a69ea0c',
        clientSecret: '41edb35ca1813906c364b894b378537819096956',
        repo: 'blogtalk',
        owner: 'Angus1996',
        admin: ['Angus1996'],
        id: (location.pathname).substring(0, 49), // Ensure uniqueness and length less than 50
        distractionFreeMode: false // Facebook-like distraction free mode
    })

    gitalk.render('gitalk-container')
</script>
                            
                                        
                                            
            </div>
    </div>
    </div>
    </div>
    
    <div id="player"></div>
    
        <footer id="footer" class="footer">
            <div class="copyright">
                
                        
                            
                                <b id="hitokoto"></b><br>
                                
                                        <svg viewBox="0 0 1024 1024" style="margin-left: 5px;margin-right: 5px;" version="1.0" width="8" height="8" class="my-face">
            <path
                d="M863.597631 513.574282l-271.33965-140.213484L729.783667 81.926656c3.583731-7.87141 7.167462-15.742819 7.167462-25.214109C736.887134 25.226908 708.345275 0.012799 672.635953 0.012799a63.611229 63.611229 0 0 0-39.293053 12.607055c-1.791866 1.59988-3.519736 3.19976-5.311602 3.19976L147.87531 418.925381a55.547834 55.547834 0 0 0-19.646527 47.356448c1.791866 17.278704 14.27093 33.021523 32.125591 42.492813l271.33965 141.749369L292.504463 945.221908c-12.479064 25.214109-1.791866 53.563983 23.166262 69.306802 10.751194 6.335525 23.230258 9.47129 35.709322 9.47129 16.062795 0 32.125591-4.735645 44.604655-15.742819l480.091993-403.297753a55.547834 55.547834 0 0 0 19.646526-47.228458 61.243407 61.243407 0 0 0-32.12559-44.156688z"
                fill="#93b5cf"></path>
        </svg>
                                        风中呓语 &copy;Copyright
                                            <script>
                                                var date = new Date();
                                                document.write("" + date.getFullYear());
                                            </script>
                                            | Powered by
                                            <a href="https://gridea.dev/" target="_blank">
                                                Gridea
                                            </a>
            </div>
            <div id="update" style="display:none;">
                off
            </div>
            
                    <script>
                        var port = '';
                        
                        document.write('<div id="home_path" style="display:none;">' + document.location.protocol + '//' + window.document.location.hostname + port + '</div>')
                    </script>
        </footer>
        
            <script src='https://cdn.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js'></script>
            
                <script>
                    

                    function LoadPlayer() {
                        var musicList = [];
                        
                        musicList.push({
                            name: '遇见',
                            url: 'http://music.163.com/song/media/outer/url?id=454828887.mp3',
                            artist: '孙燕姿',
                            cover: 'https://i.loli.net/2021/10/30/ZYLndU9WG3JuetP.png',
                        });
                        
                        musicList.push({
                            name: '夜空中最亮的星',
                            url: 'http://music.163.com/song/media/outer/url?id=25706282.mp3',
                            artist: '逃跑计划',
                            cover: 'https://i.loli.net/2021/10/30/9YOnskbf8NXgE3j.png',
                        });
                        
                        musicList.push({
                            name: '晴天',
                            url: 'http://sy.sycdn.kuwo.cn/40f0440110f81a7935cc83c2d8ec3f6d/617d2734/resource/n2/70/55/756351052.mp3',
                            artist: '周杰伦',
                            cover: 'https://i.loli.net/2021/10/30/ZlHR5KWP7wIEBDQ.png',
                        });
                        
                        musicList.push({
                            name: '回到过去',
                            url: 'https://sharefs.ali.kugou.com/202110301902/ee2933e74c5d1b20a4e1bc2df569ab33/KGTX/CLTX001/c8b0e3413696168bbdb6e931c31d139c.mp3',
                            artist: '周杰伦',
                            cover: 'https://i.loli.net/2021/10/30/6rvUMgJ2c7aYFhO.png',
                        });
                        
                        console.log(" MusicList: " + musicList);
                        
                        const ap = new APlayer({
                            container: document.getElementById('player'),
                            fixed: true,
                            audio: musicList
                        });
                        
                    }
                    LoadPlayer();
                    
                    
                    loadlive2d();
                    
                    
                    hitokoto();
                    
                    getStar();
                    hljs.initHighlighting();
                    console.clear();
                    
                    var newDate = new Date();
                    newDate.setTime(1666016988061);
                    console.log(" Blog Update Time: " + newDate.toLocaleDateString());
                    console.log("\n %c \u26a1Theme:Chic Author's Blog:https://blog.itjoker.cn  Write By ITJoker  \n\n", "color: #ffffff; background: rgba(49, 49, 49, 0.85); padding:5px 0;border-radius:5px;");
                </script>
        </div>
</body>
<script>
    scroll();
</script>

</html>